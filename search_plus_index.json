{"./":{"url":"./","title":"简介","keywords":"","body":" go-zero 0. go-zero 介绍 go-zero 是一个集成了各种工程实践的 web 和 rpc 框架。通过弹性设计保障了大并发服务端的稳定性，经受了充分的实战检验。 go-zero 包含极简的 API 定义和生成工具 goctl，可以根据定义的 api 文件一键生成 Go, iOS, Android, Kotlin, Dart, TypeScript, JavaScript 代码，并可直接运行。 使用 go-zero 的好处： 轻松获得支撑千万日活服务的稳定性 内建级联超时控制、限流、自适应熔断、自适应降载等微服务治理能力，无需配置和额外代码 微服务治理中间件可无缝集成到其它现有框架使用 极简的 API 描述，一键生成各端代码 自动校验客户端请求参数合法性 大量微服务治理和并发工具包 1. go-zero 框架背景 18 年初，我们决定从 Java+MongoDB 的单体架构迁移到微服务架构，经过仔细思考和对比，我们决定： 基于 Go 语言 高效的性能 简洁的语法 广泛验证的工程效率 极致的部署体验 极低的服务端资源成本 自研微服务框架 有过很多微服务框架自研经验 需要有更快速的问题定位能力 更便捷的增加新特性 2. go-zero 框架设计思考 对于微服务框架的设计，我们期望保障微服务稳定性的同时，也要特别注重研发效率。所以设计之初，我们就有如下一些准则： 保持简单，第一原则 弹性设计，面向故障编程 工具大于约定和文档 高可用 高并发 易扩展 对业务开发友好，封装复杂度 约束做一件事只有一种方式 我们经历不到半年时间，彻底完成了从 Java+MongoDB 到 Golang+MySQL 为主的微服务体系迁移，并于 18 年 8 月底完全上线，稳定保障了业务后续迅速增长，确保了整个服务的高可用。 3. go-zero 项目实现和特点 go-zero 是一个集成了各种工程实践的包含 web 和 rpc 框架，有如下主要特点： 强大的工具支持，尽可能少的代码编写 极简的接口 完全兼容 net/http 支持中间件，方便扩展 高性能 面向故障编程，弹性设计 内建服务发现、负载均衡 内建限流、熔断、降载，且自动触发，自动恢复 API 参数自动校验 超时级联控制 自动缓存控制 链路跟踪、统计报警等 高并发支撑，稳定保障了疫情期间每天的流量洪峰 如下图，我们从多个层面保障了整体服务的高可用： 觉得不错的话，别忘 star 👏 4. Installation 在项目目录下通过如下命令安装： GO111MODULE=on GOPROXY=https://goproxy.cn/,direct go get -u github.com/tal-tech/go-zero 5. Quick Start 完整示例请查看 快速构建高并发微服务 快速构建高并发微服务 - 多 RPC 版 安装 goctl 工具 goctl 读作 go control，不要读成 go C-T-L。goctl 的意思是不要被代码控制，而是要去控制它。其中的 go 不是指 golang。在设计 goctl 之初，我就希望通过 她 来解放我们的双手👈 GO111MODULE=on GOPROXY=https://goproxy.cn/,direct go get -u github.com/tal-tech/go-zero/tools/goctl 确保 goctl 可执行 快速生成 api 服务 goctl api new greet cd greet go mod init go mod tidy go run greet.go -f etc/greet-api.yaml 默认侦听在 8888 端口（可以在配置文件里修改），可以通过 curl 请求： curl -i http://localhost:8888/from/you 返回如下： HTTP/1.1 200 OK Content-Type: application/json Date: Thu, 22 Oct 2020 14:03:18 GMT Content-Length: 14 {\"message\":\"\"} 编写业务代码： api 文件定义了服务对外暴露的路由，可参考 api 规范 可以在 servicecontext.go 里面传递依赖给 logic，比如 mysql, redis 等 在 api 定义的 get/post/put/delete 等请求对应的 logic 里增加业务处理逻辑 可以根据 api 文件生成前端需要的 Java, TypeScript, Dart, JavaScript 代码 goctl api java -api greet.api -dir greet goctl api dart -api greet.api -dir greet ... 6. Benchmark 测试代码见这里 7. 文档 API 文档 https://www.yuque.com/tal-tech/go-zero awesome 系列（更多文章见『微服务实践』公众号） 快速构建高并发微服务 快速构建高并发微服务 - 多 RPC 版 goctl 使用帮助 精选 goctl 插件 插件 用途 goctl-swagger 一键生成 api 的 swagger 文档 goctl-android 生成 java (android) 端 http client 请求代码 goctl-go-compact 合并 api 里同一个 group 里的 handler 到一个 go 文件 8. 微信公众号 go-zero 相关文章都会在 微服务实践 公众号整理呈现，欢迎扫码关注，也可以通过公众号私信我 👏 9. 微信交流群 如果文档中未能覆盖的任何疑问，欢迎您在群里提出，我们会尽快答复。 您可以在群内提出使用中需要改进的地方，我们会考虑合理性并尽快修改。 如果您发现 bug 请及时提 issue，我们会尽快确认并修改。 为了防止广告用户、识别技术同行，请 star 后加我时注明 github 当前 star 数，我再拉进 go-zero 群，感谢！ 加我之前有劳点一下 star，一个小小的 star 是作者们回答海量问题的动力🤝 项目地址：https://github.com/tal-tech/go-zero 码云地址：https://gitee.com/kevwan/go-zero (国内用户可访问gitee，每日自动从github同步代码) Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 14:46:20 "},"about-us.html":{"url":"about-us.html","title":"关于我们","keywords":"","body":"关于我们 go-zero go-zero 是一个集成了各种工程实践的 web 和 rpc 框架。通过弹性设计保障了大并发服务端的稳定性，经受了充分的实战检验。 go-zero 包含极简的 API 定义和生成工具 goctl，可以根据定义的 api 文件一键生成 Go, iOS, Android, Kotlin, Dart, TypeScript, JavaScript 代码，并可直接运行。 go-zero作者 万俊峰，晓黑板研发负责人，好未来资深技术专家，拥有14年研发团队管理经验，16年架构设计经验，20年工程实战经验，负责过多个大型项目的架构设计，曾多次合伙创业（被收购），GopherChina大会讲师，腾讯云开发者大会讲师。 go-zero成员 go-zero截止2021年2月，目前拥有30人的团队开发人员及50+的社区成员。 go-zero社区 我们目前拥有3000多人的社区成员，在这里，你可以和大家讨论任何关于go-zero的技术，问题反馈，获取最新的go-zero信息，以及各位大佬每天分享的技术心得。 go-zero社区群 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 14:26:36 "},"join-us.html":{"url":"join-us.html","title":"加入我们","keywords":"","body":"加入我们 概要 go-zero 是一个基于MIT License 的开源项目，大家在使用中发现bug，有新的特性等，均可以参与到go-zero的贡献中来，我们非常欢迎大家的积极参与，也会最快响应大家提出的各种问题，pr等。 贡献形式 Pull Request Issue 贡献须知 go-zero 的Pull request中的代码需要满足一定规范 命名规范，请阅读命名规范 以英文注释为主 pr时备注好功能特性，描述需要清晰，简洁 增加单元测试覆盖率达80%+ 贡献代码（pr） 进入go-zero 项目，fork一份go-zero 项目到自己的github仓库中。 回到自己的github主页，找到xx/go-zero项目，其中xx为你的用户名，如anqiansong/go-zero 克隆代码到本地 开发代码，push到自己的github仓库 进入自己的github中go-zero项目，点击浮层上的的【Pull requests】进入Compare页面。 base repository选择tal-tech/go-zero base:master,head repository选择xx/go-zero compare:$branch ，$branch为你开发的分支，如图： 点击【Create pull request】即可实现pr申请 确认pr是否提交成功，进入go-zero 的Pull requests 查看，应该有自己提交的记录，名称为你的开发时的分支名称 Issue 在我们的社区中，有很多伙伴会积极的反馈一些go-zero使用过程中遇到的问题，由于社区人数较多，我们虽然会实时的关注社区动态，但大家问题反馈过来都是随机的，当我们团队还在解决某一个伙伴提出的问题时，另外的问题也反馈上来，可能会导致团队会很容易忽略掉，为了能够一一的解决大家的问题，我们强烈建议大家通过issue的方式来反馈问题，包括但不限于bug，期望的新功能特性等，我们在实现某一个新特性时也会在issue中体现，大家在这里也能够在这里获取到go-zero的最新动向，也欢迎大家来积极的参与讨论。 怎么提Issue 点击这里 进入go-zero的Issue页面或者直接访问https://github.com/tal-tech/go-zero/issues 地址 点击右上角的【New issue】新建issue 填写issue标题和内容 点击【Submit new issue】提交issue 参考文档 Pull request Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 14:46:20 "},"concept-introduction.html":{"url":"concept-introduction.html","title":"概念介绍","keywords":"","body":"概念介绍 go-zero 晓黑板golang开源项目，集各种工程实践于一身的web和rpc框架。 goctl 一个旨在为开发人员提高工程效率、降低出错率的辅助工具。 goctl插件 指以goctl为中心的周边二进制资源，能够满足一些个性化的代码生成需求，如路由合并插件goctl-go-compact插件， 生成swagger文档的goctl-swagger插件，生成php调用端的goctl-php插件等。 intellij/vscode插件 在intellij系列产品上配合goctl开发的插件，其将goctl命令行操作使用UI进行替代。 api文件 api文件是指用于定义和描述api服务的文本文件，其以.api后缀结尾，包含api语法描述内容。 goctl环境 goctl环境是使用goctl前的准备环境，包含 golang环境 protoc protoc-gen-go插件 go module | gopath go-zero-demo go-zero-demo里面包含了文档中所有源码的一个大仓库，后续我们在编写演示demo时，我们均在此项目下创建子项目， 因此我们需要提前创建一个大仓库go-zero-demo，我这里把这个仓库放在home目录下。 $ cd ~ $ mkdir go-zero-demo&&cd go-zero-demo $ go mod init go-zero-demo 参考文档 go-zero Goctl 插件中心 工具中心 api语法 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 12:07:00 "},"quick-start.html":{"url":"quick-start.html","title":"快速开发","keywords":"","body":"快速开发 本节主要通过对api/rpc等服务快速开始来让大家对使用go-zero开发的工程有一个宏观概念， 对于更加详细的介绍我们将在后续一一展开，本节将包含一下小节： 单体服务 微服务 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 23:27:45 "},"monolithic-service.html":{"url":"monolithic-service.html","title":"单体服务","keywords":"","body":"单体服务 前言 由于go-zero集成了web/rpc于一体，社区有部分小伙伴会问我，go-zero的定位是否是一款微服务框架， 答案是否定的，go-zero虽然集众多功能于一身，但你可以将其中任何一个功能独立出来去单独使用，也可以开发单体服务， 不是说每个服务上来就一定要采用微服务的架构的设计，这点大家可以看看作者(kevin)的第四期开源说 ，其中对此有详细的讲解。 创建greet服务 $ cd ~/go-zero-demo $ goctl api new greet Done. 查看一下greet服务的结构 $ cd greet $ tree . ├── etc │ └── greet-api.yaml ├── go.mod ├── greet.api ├── greet.go └── internal ├── config │ └── config.go ├── handler │ ├── greethandler.go │ └── routes.go ├── logic │ └── greetlogic.go ├── svc │ └── servicecontext.go └── types └── types.go 由以上目录结构可以观察到，greet服务虽小，但\"五脏俱全\"。接下来我们就可以在greetlogic.go中编写业务代码了。 编写逻辑 $ vim ~/go-zero-demo/greet/internal/logic/greetlogic.go func (l *GreetLogic) Greet(req types.Request) (*types.Response, error) { return &types.Response{ Message: \"Hello go-zero\", }, nil } 启动并访问服务 启动服务 $ cd ~/go-zer-demo/greet $ go run greet.go -f etc/greet-api.yaml Starting server at 0.0.0.0:8888... 访问服务 $ curl -i -X GET \\ http://localhost:8888/from/you HTTP/1.1 200 OK Content-Type: application/json Date: Sun, 07 Feb 2021 04:31:25 GMT Content-Length: 27 {\"message\":\"Hello go-zero\"} 源码 greet源码 猜你想看 goctl使用说明 api目录结构介绍 api语法 api配置文件介绍 api中间件使用 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 12:45:19 "},"micro-service.html":{"url":"micro-service.html","title":"微服务","keywords":"","body":"微服务 在上一篇我们已经演示了怎样快速创建一个单体服务，接下来我们来演示一下如何快速创建微服务， 在本小节中，api部分其实和单体服务的创建逻辑是一样的，只是在单体服务中没有服务间的通讯而已， 且微服务中api服务会多一些rpc调用的配置。 前言 本小节将以一个订单服务调用用户服务来简单演示一下，演示代码仅传递思路，其中有些环节不会一一列举。 情景提要 假设我们在开发一个商城项目，而开发者小明负责用户模块(user)和订单模块(order)的开发，我们姑且将这两个模块拆分成两个微服务① [!NOTE] ①：微服务的拆分也是一门学问，这里我们就不讨论怎么去拆分微服务的细节了。 演示功能目标 订单服务(order)提供一个查询接口 用户服务(user)提供一个方法供订单服务获取用户信息 服务设计分析 根据情景提要我们可以得知，订单是直接面向用户，通过http协议访问数据，而订单内部需要获取用户的一些基础数据，既然我们的服务是采用微服务的架构设计， 那么两个服务（user,order）就必须要进行数据交换，服务间的数据交换即服务间的通讯，到了这里，采用合理的通讯协议也是一个开发人员需要 考虑的事情，可以通过http，rpc等方式来进行通讯，这里我们选择rpc来实现服务间的通讯，相信这里我已经对\"rpc服务存在有什么作用？\"已经作了一个比较好的场景描述。 当然，一个服务开发前远不止这点设计分析，我们这里就不详细描述了。从上文得知，我们需要一个 user rpc order api 两个服务来初步实现这个小demo。 创建mall工程 $ cd ~/go-zero-demo $ mkdir mall && cd mall 创建user rpc服务 创建user rpc服务 $ cd ~/go-zero-demo/mall $ mkdir -p user/rpc&&cd user/rpc 添加user.proto文件，增加getUser方法 $ vim ~/go-zero-demo/mall/user/user.proto syntax = \"proto3\"; package user; message IdRequest { string id = 1; } message UserResponse { // 用户id string id = 1; // 用户名称 string name = 2; // 用户性别 string gender = 3; } service User { rpc getUser(IdRequest) returns(UserResponse); } 生成代码 $ cd ~/go-zero-demo/mall/user/rpc $ goctl rpc proto -src user.proto -dir . protoc -I=/Users/xx/mall/user user.proto --go_out=plugins=grpc:/Users/xx/mall/user/user Done. 填充业务逻辑 $ vim vi internal/logic/getuserlogic.go package logic import ( \"context\" \"go-zero-demo/mall/user/internal/svc\" \"go-zero-demo/mall/user/user\" \"github.com/tal-tech/go-zero/core/logx\" ) type GetUserLogic struct { ctx context.Context svcCtx *svc.ServiceContext logx.Logger } func NewGetUserLogic(ctx context.Context, svcCtx *svc.ServiceContext) *GetUserLogic { return &GetUserLogic{ ctx: ctx, svcCtx: svcCtx, Logger: logx.WithContext(ctx), } } func (l *GetUserLogic) GetUser(in *user.IdRequest) (*user.UserResponse, error) { return &user.UserResponse{ Id: \"1\", Name: \"test\", }, nil } 创建order api服务 创建 order api服务 $ cd ~/go-zero-demo/mall $ mkdir -p order/api&&cd order/api 添加api文件 $ vim order.api type( OrderReq { Id string `path:\"id\"` } OrderReply { Id string `json:\"id\"` Name string `json:\"name\"` } ) service order { @handler getOrder get /api/order/get/:id (OrderReq) returns (OrderReply) } 生成order服务 $ goctl api go -api order.api -dir . Done. 添加user rpc配置 $ vim internal/config/config.go package config import \"github.com/tal-tech/go-zero/rest\" import \"github.com/tal-tech/go-zero/zrpc\" type Config struct { rest.RestConf UserRpc zrpc.RpcClientConf } 添加yaml配置 $ vim etc/order.yaml Name: order Host: 0.0.0.0 Port: 8888 UserRpc: Etcd: Hosts: - 127.0.0.1:2379 Key: user.rpc 完善服务依赖 $ vim internal/svc/servicecontext.go package svc import ( \"go-zero-demo/mall/order/api/internal/config\" \"go-zero-demo/mall/user/rpc/userclient\" \"github.com/tal-tech/go-zero/zrpc\" ) type ServiceContext struct { Config config.Config UserRpc userclient.User } func NewServiceContext(c config.Config) *ServiceContext { return &ServiceContext{ Config: c, UserRpc: userclient.NewUser(zrpc.MustNewClient(c.UserRpc)), } } 添加order演示逻辑 给getorderlogic添加业务逻辑 $ vim ~/go-zero-demo/mall/order/api/internal/logic/getorderlogic.go user, err := l.svcCtx.UserRpc.GetUser(l.ctx, &userclient.IdRequest{ Id: \"1\", }) if err != nil { return nil, err } if user.Name != \"test\" { return nil, errors.New(\"用户不存在\") } return &types.OrderReply{ Id: req.Id, Name: \"test order\", }, nil 启动服务并验证 启动etcd$ etcd 启动user rpc$ go run user.go -f etc/user.yaml Starting rpc server at 127.0.0.1:8080... [!TIP] 如果启动报类似not enough arguments in call to base.NewBalancerBuilder的错误，请查阅常见错误处理 启动order api$ go run order.go -f etc/order.yaml Starting server at 0.0.0.0:8888... 访问order api curl -i -X GET \\ http://localhost:8888/api/order/get/1 HTTP/1.1 200 OK Content-Type: application/json Date: Sun, 07 Feb 2021 03:45:05 GMT Content-Length: 30 {\"id\":\"1\",\"name\":\"test order\"} [!TIP] 在演示中的提及的api语法，rpc生成，goctl，goctl环境等怎么使用和安装，快速入门中不作详细概述，我们后续都会有详细的文档进行描述，你也可以点击下文的【猜你想看】快速跳转的对应文档查看。 源码 mall源码 猜你想看 goctl使用说明 api目录结构介绍 api语法 api配置文件介绍 api中间件使用 rpc目录 rpc配置 rpc调用方说明 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 12:45:19 "},"framework-design.html":{"url":"framework-design.html","title":"框架设计","keywords":"","body":"框架设计 本节将从go-zero的设计理念，go-zerp服务的最佳实践目录来说明go-zero框架的设计，本节将包含以下小节： go-zero设计理念 api语法介绍 api目录结构 rpc目录结构 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 14:12:01 "},"go-zero-design.html":{"url":"go-zero-design.html","title":"go-zero设计理念","keywords":"","body":"go-zero设计理念 对于微服务框架的设计，我们期望保障微服务稳定性的同时，也要特别注重研发效率。所以设计之初，我们就有如下一些准则： 保持简单，第一原则 弹性设计，面向故障编程 工具大于约定和文档 高可用 高并发 易扩展 对业务开发友好，封装复杂度 约束做一件事只有一种方式 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 13:38:52 "},"go-zero-features.html":{"url":"go-zero-features.html","title":"go-zero特点","keywords":"","body":"go-zero特性 go-zero 是一个集成了各种工程实践的包含 web 和 rpc 框架，有如下主要特点： 强大的工具支持，尽可能少的代码编写 极简的接口 完全兼容 net/http 支持中间件，方便扩展 高性能 面向故障编程，弹性设计 内建服务发现、负载均衡 内建限流、熔断、降载，且自动触发，自动恢复 API 参数自动校验 超时级联控制 自动缓存控制 链路跟踪、统计报警等 高并发支撑，稳定保障了疫情期间每天的流量洪峰 如下图，我们从多个层面保障了整体服务的高可用： Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 14:32:57 "},"api-grammar.html":{"url":"api-grammar.html","title":"api语法介绍","keywords":"","body":"api语法介绍 api示例 /** * api语法示例及语法说明 */ // api语法版本 syntax = \"v1\" // import literal import \"foo.api\" // import group import ( \"bar.api\" \"foo/bar.api\" ) info( author: \"songmeizi\" date: \"2020-01-08\" desc: \"api语法示例及语法说明\" ) // type literal type Foo{ Foo int `json:\"foo\"` } // type group type( Bar{ Bar int `json:\"bar\"` } ) // service block @server( jwt: Auth group: foo ) service foo-api{ @doc \"foo\" @handler foo post /foo (Foo) returns (Bar) } api语法结构 syntax语法声明 import语法块 info语法块 type语法块 service语法块 隐藏通道 [!TIP] 在以上语法结构中，各个语法块从语法上来说，按照语法块为单位，可以在.api文件中任意位置声明， 但是为了提高阅读效率，我们建议按照以上顺序进行声明，因为在将来可能会通过严格模式来控制语法块的顺序。 syntax语法声明 syntax是新加入的语法结构，该语法的引入可以解决： 快速针对api版本定位存在问题的语法结构 针对版本做语法解析 防止api语法大版本升级导致前后不能向前兼容 **[!WARNING] 被import的api必须要和main api的syntax版本一致。 语法定义 'syntax'={checkVersion(p)}STRING 语法说明 syntax：固定token，标志一个syntax语法结构的开始 checkVersion：自定义go方法，检测STRING是否为一个合法的版本号，目前检测逻辑为，STRING必须是满足(?m)\"v[1-9][0-9]*\"正则。 STRING：一串英文双引号包裹的字符串，如\"v1\" 一个api语法文件只能有0或者1个syntax语法声明，如果没有syntax，则默认为v1版本 正确语法示例 ✅ eg1：不规范写法 syntax=\"v1\" eg2：规范写法(推荐) syntax = \"v2\" 错误语法示例 ❌ eg1： syntax = \"v0\" eg2： syntax = v1 eg3： syntax = \"V1\" import语法块 随着业务规模增大，api中定义的结构体和服务越来越多，所有的语法描述均为一个api文件，这是多么糟糕的一个问题， 其会大大增加了阅读难度和维护难度，import语法块可以帮助我们解决这个问题，通过拆分api文件， 不同的api文件按照一定规则声明，可以降低阅读难度和维护难度。 **[!WARNING] 这里import不像golang那样包含package声明，仅仅是一个文件路径的引入，最终解析后会把所有的声明都汇聚到一个spec.Spec中。 不能import多个相同路径，否则会解析错误。 语法定义 'import' {checkImportValue(p)}STRING |'import' '(' ({checkImportValue(p)}STRING)+ ')' 语法说明 import：固定token，标志一个import语法的开始 checkImportValue：自定义go方法，检测STRING是否为一个合法的文件路径，目前检测逻辑为，STRING必须是满足(?m)\"(/?[a-zA-Z0-9_#-])+\\.api\"正则。 STRING：一串英文双引号包裹的字符串，如\"foo.api\" 正确语法示例 ✅ eg： import \"foo.api\" import \"foo/bar.api\" import( \"bar.api\" \"foo/bar/foo.api\" ) 错误语法示例 ❌ eg： import foo.api import \"foo.txt\" import ( bar.api bar.api ) info语法块 info语法块是一个包含了多个键值对的语法体，其作用相当于一个api服务的描述，解析器会将其映射到spec.Spec中， 以备用于翻译成其他语言(golang、java等) 时需要携带的meta元素。如果仅仅是对当前api的一个说明，而不考虑其翻译 时传递到其他语言，则使用简单的多行注释或者java风格的文档注释即可，关于注释说明请参考下文的 隐藏通道。 **[!WARNING] 不能使用重复的key，每个api文件只能有0或者1个info语法块 语法定义 'info' '(' (ID {checkKeyValue(p)}VALUE)+ ')' 语法说明 info：固定token，标志一个info语法块的开始 checkKeyValue：自定义go方法，检测VALUE是否为一个合法值。 VALUE：key对应的值，可以为单行的除'\\r','\\n','/'后的任意字符，多行请以\"\"包裹，不过强烈建议所有都以\"\"包裹 正确语法示例 ✅ eg1：不规范写法 info( foo: foo value bar:\"bar value\" desc:\"long long long long long long text\" ) eg2：规范写法(推荐) info( foo: \"foo value\" bar: \"bar value\" desc: \"long long long long long long text\" ) 错误语法示例 ❌ eg1：没有key-value内容 info() eg2：不包含冒号 info( foo value ) eg3：key-value没有换行 info(foo:\"value\") eg4：没有key info( : \"value\" ) eg5：非法的key info( 12: \"value\" ) eg6：移除旧版本多行语法 info( foo: > some text type语法块 在api服务中，我们需要用到一个结构体(类)来作为请求体，响应体的载体，因此我们需要声明一些结构体来完成这件事情， type语法块由golang的type演变而来，当然也保留着一些golang type的特性，沿用golang特性有： 保留了golang内置数据类型bool,int,int8,int16,int32,int64,uint,uint8,uint16,uint32,uint64,uintptr ,float32,float64,complex64,complex128,string,byte,rune, 兼容golang struct风格声明 保留golang关键字 **[!WARNING]️ 不支持alias 不支持time.Time数据类型 结构体名称、字段名称、不能为golang关键字 语法定义 由于其和golang相似，因此不做详细说明，具体语法定义请在ApiParser.g4中查看typeSpec定义。 语法说明 参考golang写法 正确语法示例 ✅ eg1：不规范写法 type Foo struct{ Id int `path:\"id\"` // ① Foo int `json:\"foo\"` } type Bar struct{ // 非导出型字段 bar int `form:\"bar\"` } type( // 非导出型结构体 fooBar struct{ FooBar int } ) eg2：规范写法（推荐） type Foo{ Id int `path:\"id\"` Foo int `json:\"foo\"` } type Bar{ Bar int `form:\"bar\"` } type( FooBar{ FooBar int } ) 错误语法示例 ❌ eg type Gender int // 不支持 // 非struct token type Foo structure{ CreateTime time.Time // 不支持time.Time } // golang关键字 var type var{} type Foo{ // golang关键字 interface Foo interface } type Foo{ foo int // map key必须要golang内置数据类型 m map[Bar]string } [!NOTE] ① tag定义和golang中json tag语法一样，除了json tag外，go-zero还提供了另外一些tag来实现对字段的描述， 详情见下表。 tag表 tag key 描述 提供方有效范围 示例 json json序列化tag golang request、response json:\"fooo\" path 路由path，如/foo/:id go-zero request path:\"id\" form 标志请求体是一个form（POST方法时）或者一个query(GET方法时/search?name=keyword) go-zero request form:\"name\" tag修饰符 常见参数校验描述 tag key 描述 提供方 有效范围 示例 optional 定义当前字段为可选参数 go-zero request json:\"name,optional\" options 定义当前字段的枚举值,多个以竖线|隔开 go-zero request json:\"gender,options=male\" default 定义当前字段默认值 go-zero request json:\"gender,default=male\" range 定义当前字段数值范围 go-zero request json:\"age,range=[0:120]\" [!TIP] tag修饰符需要在tag value后以引文逗号,隔开 service语法块 service语法块用于定义api服务，包含服务名称，服务metadata，中间件声明，路由，handler等。 **[!WARNING]️ main api和被import的api服务名称必须一致，不能出现服务名称歧义。 handler名称不能重复 路由（请求方法+请求path）名称不能重复 请求体必须声明为普通（非指针）struct，响应体做了一些向前兼容处理，详请见下文说明 语法定义 serviceSpec: atServer? serviceApi; atServer: '@server' lp='(' kvLit+ rp=')'; serviceApi: {match(p,\"service\")}serviceToken=ID serviceName lbrace='{' serviceRoute* rbrace='}'; serviceRoute: atDoc? (atServer|atHandler) route; atDoc: '@doc' lp='('? ((kvLit+)|STRING) rp=')'?; atHandler: '@handler' ID; route: {checkHttpMethod(p)}httpMethod=ID path request=body? returnToken=ID? response=replybody?; body: lp='(' (ID)? rp=')'; replybody: lp='(' dataType? rp=')'; // kv kvLit: key=ID {checkKeyValue(p)}value=LINE_VALUE; serviceName: (ID '-'?)+; path: (('/' (ID ('-' ID)*))|('/:' (ID ('-' ID)?)))+; 语法说明 serviceSpec：包含了一个可选语法块atServer和serviceApi语法块，其遵循序列模式（编写service必须要按照顺序，否则会解析出错） atServer： 可选语法块，定义key-value结构的server metadata，'@server' 表示这一个server语法块的开始，其可以用于描述serviceApi或者route语法块，其用于描述不同语法块时有一些特殊关键key 需要值得注意，见 atServer关键key描述说明。 serviceApi：包含了1到多个serviceRoute语法块 serviceRoute：按照序列模式包含了atDoc,handler和route atDoc：可选语法块，一个路由的key-value描述，其在解析后会传递到spec.Spec结构体，如果不关心传递到spec.Spec, 推荐用单行注释替代。 handler：是对路由的handler层描述，可以通过atServer指定handler key来指定handler名称， 也可以直接用atHandler语法块来定义handler名称 atHandler：'@handler' 固定token，后接一个遵循正则[_a-zA-Z][a-zA-Z_-]*)的值，用于声明一个handler名称 route：路由，有httpMethod、path、可选request、可选response组成，httpMethod是必须是小写。 body：api请求体语法定义，必须要由()包裹的可选的ID值 replyBody：api响应体语法定义，必须由()包裹的struct、array(向前兼容处理，后续可能会废弃，强烈推荐以struct包裹，不要直接用array作为响应体) kvLit： 同info key-value serviceName: 可以有多个'-'join的ID值 path：api请求路径，必须以'/'或者'/:'开头，切不能以'/'结尾，中间可包含ID或者多个以'-'join的ID字符串 atServer关键key描述说明 修饰service时 key描述示例 jwt声明当前service下所有路由需要jwt鉴权，且会自动生成包含jwt逻辑的代码jwt: Auth group声明当前service或者路由文件分组group: login middleware声明当前service需要开启中间件middleware: AuthMiddleware 修饰route时 key描述示例 handler声明一个handler- 正确语法示例 ✅ eg1：不规范写法 @server( jwt: Auth group: foo middleware: AuthMiddleware ) service foo-api{ @doc( summary: foo ) @server( handler: foo ) // 非导出型body post /foo/:id (foo) returns (bar) @doc \"bar\" @handler bar post /bar returns ([]int)// 不推荐数组作为响应体 @handler fooBar post /foo/bar (Foo) returns // 可以省略'returns' } eg2：规范写法（推荐） @server( jwt: Auth group: foo middleware: AuthMiddleware ) service foo-api{ @doc \"foo\" @handler: foo post /foo/:id (Foo) returns (Bar) } service foo-api{ @handler ping get /ping @doc \"foo\" @handler: bar post /bar/:id (Foo) } 错误语法示例 ❌ // 不支持空的server语法块 @server( ) // 不支持空的service语法块 service foo-api{ } service foo-api{ @doc kkkk // 简版doc必须用英文双引号引起来 @handler foo post /foo @handler foo // 重复的handler post /bar @handler fooBar post /bar // 重复的路由 // @handler和@doc顺序错误 @handler someHandler @doc \"some doc\" post /some/path // handler缺失 post /some/path/:id @handler reqTest post /foo/req (*Foo) // 不支持除普通结构体外的其他数据类型作为请求体 @handler replyTest post /foo/reply returns (*Foo) // 不支持除普通结构体、数组(向前兼容，后续考虑废弃)外的其他数据类型作为响应体 } 隐藏通道 隐藏通道目前主要为空百符号，换行符号以及注释，这里我们只说注释，因为空白符号和换行符号我们目前拿来也无用。 单行注释 语法定义 '//' ~[\\r\\n]* 语法说明 由语法定义可知道，单行注释必须要以//开头，内容为不能包含换行符 正确语法示例 ✅ // doc // comment 错误语法示例 ❌ // break line comments java风格文档注释 语法定义 '/*' .*? '*/' 语法说明 由语法定义可知道，单行注释必须要以/*开头，*/结尾的任意字符。 正确语法示例 ✅ /** * java-style doc */ 错误语法示例 ❌ /* * java-style doc */ */ Doc&Comment 如果想获取某一个元素的doc或者comment开发人员需要怎么定义？ Doc 我们规定上一个语法块（非隐藏通道内容）的行数line+1到当前语法块第一个元素前的所有注释(当行，或者多行)均为doc， 且保留了//、/*、*/原始标记。 Comment 我们规定当前语法块最后一个元素所在行开始的一个注释块(当行，或者多行)为comment 且保留了//、/*、*/原始标记。 语法块Doc和Comment的支持情况 语法块parent语法块DocComment syntaxLitapi✅✅ kvLitinfoSpec✅✅ importLitimportSpec✅✅ typeLitapi✅❌ typeLittypeBlock✅❌ fieldtypeLit✅✅ key-valueatServer✅✅ atHandlerserviceRoute✅✅ routeserviceRoute✅✅ 以下为对应语法块解析后细带doc和comment的写法 // syntaxLit doc syntax = \"v1\" // syntaxLit commnet info( // kvLit doc author: songmeizi // kvLit comment ) // typeLit doc type Foo {} type( // typeLit doc Bar{} FooBar{ // filed doc Name int // filed comment } ) @server( /** * kvLit doc * 开启jwt鉴权 */ jwt: Auth /**kvLit comment*/ ) service foo-api{ // atHandler doc @handler foo //atHandler comment /* * route doc * post请求 * path为 /foo * 请求体：Foo * 响应体：Foo */ post /foo (Foo) returns (Foo) // route comment } Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 14:20:33 "},"api-dir.html":{"url":"api-dir.html","title":"api目录结构","keywords":"","body":"api目录介绍 . ├── etc │ └── greet-api.yaml // 配置文件 ├── go.mod // mod文件 ├── greet.api // api描述文件 ├── greet.go // main函数入口 └── internal ├── config │ └── config.go // 配置声明type ├── handler // 路由及handler转发 │ ├── greethandler.go │ └── routes.go ├── logic // 业务逻辑 │ └── greetlogic.go ├── middleware // 中间件文件 │ └── greetmiddleware.go ├── svc // logic所依赖的资源池 │ └── servicecontext.go └── types // request、response的struct，根据api自动生成，不建议编辑 └── types.go Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 14:07:09 "},"rpc-dir.html":{"url":"rpc-dir.html","title":"rpc目录结构","keywords":"","body":"rpc服务目录 . ├── etc // yaml配置文件 │ └── greet.yaml ├── go.mod ├── greet // pb.go文件夹① │ └── greet.pb.go ├── greet.go // main函数 ├── greet.proto // proto 文件 ├── greetclient // call logic ② │ └── greet.go └── internal ├── config // yaml配置对应的实体 │ └── config.go ├── logic // 业务代码 │ └── pinglogic.go ├── server // rpc server │ └── greetserver.go └── svc // 依赖资源 └── servicecontext.go [!TIP] ① pb文件夹名（老版本文件夹固定为pb）称取自于proto文件中option go_package的值最后一层级按照一定格式进行转换，若无此声明，则取自于package的值，大致代码如下： if option.Name == \"go_package\" { ret.GoPackage = option.Constant.Source } ... if len(ret.GoPackage) == 0 { ret.GoPackage = ret.Package.Name } ret.PbPackage = GoSanitized(filepath.Base(ret.GoPackage)) ... [!TIP] GoSanitized方法请参考google.golang.org/protobuf@v1.25.0/internal/strs/strings.go:71 [!TIP] ② call 层文件夹名称取自于proto中service的名称，如该sercice的名称和pb文件夹名称相等，则会在srervice后面补充client进行区分，使pb和call分隔。 if strings.ToLower(proto.Service.Name) == strings.ToLower(proto.GoPackage) { callDir = filepath.Join(ctx.WorkDir, strings.ToLower(stringx.From(proto.Service.Name+\"_client\").ToCamel())) } Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 14:09:55 "},"project-dev.html":{"url":"project-dev.html","title":"项目开发","keywords":"","body":"项目开发 在前面的章节我们已经从一些概念、背景、快速入门等维度介绍了一下go-zero，看到这里，相信你对go-zero已经有了一些了解， 从这里开始，我们将会从环境准备到服务部署整个流程开始进行讲解，为了保证大家能够彻底弄懂go-zero的开发流程，那就准备你的耐心来接着往下走吧。 在章节中，将包含以下小节： 准备工作 golang安装 goctl安装 protoc&protoc-gen-go安装 go mod配置 开发规范 命名规范 路由规范 编码规范 开发流程 配置介绍 api配置 rpc配置 业务开发 jwt鉴权 中间件使用 model生成 rpc调用 业务编码 错误处理 服务启动 CI/CD 服务部署 日志收集 服务监控 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 15:24:57 "},"prepare.html":{"url":"prepare.html","title":"准备工作","keywords":"","body":"准备工作 在正式进入实际开发之前，我们需要做一些准备工作，比如：Go环境的安装，grpc代码生成使用的工具安装， 必备工具Goctl的安装，Golang环境配置等，本节将包含以下小节： golang安装 go modudle配置 goctl安装 protoc&protoc-gen-go安装 其他 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 15:51:15 "},"golang-install.html":{"url":"golang-install.html","title":"golang安装","keywords":"","body":"Golang环境安装 前言 开发golang程序，必然少不了对其环境的安装，我们这里选择以1.15.1为例。 官方文档 https://golang.google.cn/doc/install mac OS安装Go 下载并安装Go for Mac 验证安装结果 $ go version go version go1.15.1 darwin/amd64 linux 安装Go 下载Go for Linux 解压压缩包至/usr/local $ tar -C /usr/local -xzf go1.15.8.linux-amd64.tar.gz 添加/usr/local/go/bin到环境变量 $ $HOME/.profile export PATH=$PATH:/usr/local/go/bin $ source $HOME/.profile 验证安装结果 $ go version go version go1.15.1 linux/amd64 Windows安装Go 下载并安装Go for Windows 验证安装结果 $ go version go version go1.15.1 windows/amd64 其他 更多操作系统安装见https://golang.org/dl/ Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 15:51:15 "},"gomod-config.html":{"url":"gomod-config.html","title":"go modudle配置","keywords":"","body":"Go Module设置 Go Module介绍 Modules are how Go manages dependencies.[1] 即Go Module是Golang管理依赖性的方式，像Java中的Maven，Android中的Gradle类似。 MODULE配置 查看GO111MODULE开启情况 $ go env GO111MODULE on 开启GO111MODULE，如果已开启（即执行go env GO111MODULE结果为on）请跳过。 $ go env -w GO111MODULE=\"on\" 设置GOPROXY $ go env -w GOPROXY=https://goproxy.cn 设置GOMODCACHE 查看GOMODCACHE $ go env GOMODCACHE 如果目录不为空或者/dev/null，请跳过。 go env -w GOMODCACHE=$GOPATH/pkg/mod 参考文档 [1] Go Modules Reference Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 16:26:46 "},"goctl-install.html":{"url":"goctl-install.html","title":"goctl安装","keywords":"","body":"Goctl安装 前言 Goctl在go-zero项目开发着有着很大的作用，其可以有效的帮助开发者大大提高开发效率，减少代码的出错率，缩短业务开发的工作量，更多的Goctl的介绍请阅读Goctl介绍, 在这里我们强烈推荐大家安装，因为后续演示例子中我们大部分都会以goctl进行演示。 安装(mac&linux) download&install GO111MODULE=on GOPROXY=https://goproxy.cn/,direct go get -u github.com/tal-tech/go-zero 环境变量检测 go get下载编译后的二进制文件位于$GOPATH/bin目录下，要确保$GOPATH/bin已经添加到环境变量。 $ sudo vim /etc/paths 在最后一行添加如下内容 $GOPATH/bin [!TIP] $GOPATH为你本机上的文件地址 安装结果验证 $ goctl -v goctl version 1.1.4 darwin/amd64 [!TIP] windows用户添加环境变量请自行google Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 16:23:34 "},"protoc-install.html":{"url":"protoc-install.html","title":"protoc&protoc-gen-go安装","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:47:23 "},"prepare-other.html":{"url":"prepare-other.html","title":"其他","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 15:27:45 "},"dev-specification.html":{"url":"dev-specification.html","title":"开发规范","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:47:40 "},"naming-spec.html":{"url":"naming-spec.html","title":"命名规范","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:47:47 "},"route-naming-spec.html":{"url":"route-naming-spec.html","title":"路由规范","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:47:54 "},"coding-spec.html":{"url":"coding-spec.html","title":"编码规范","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:48:01 "},"dev-flow.html":{"url":"dev-flow.html","title":"开发流程","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:48:09 "},"config-introduction.html":{"url":"config-introduction.html","title":"配置介绍","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:48:17 "},"api-config.html":{"url":"api-config.html","title":"api配置","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:48:25 "},"rpc-config.html":{"url":"rpc-config.html","title":"rpc配置","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:48:32 "},"business-dev.html":{"url":"business-dev.html","title":"业务开发","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:48:40 "},"jwt.html":{"url":"jwt.html","title":"jwt鉴权","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:48:46 "},"middleware.html":{"url":"middleware.html","title":"中间件使用","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:48:53 "},"model-gen.html":{"url":"model-gen.html","title":"model生成","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:49:00 "},"rpc-call.html":{"url":"rpc-call.html","title":"rpc调用","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:49:07 "},"business-coding.html":{"url":"business-coding.html","title":"业务编码","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:49:14 "},"error-handle.html":{"url":"error-handle.html","title":"错误处理","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:49:21 "},"service-start.html":{"url":"service-start.html","title":"服务启动","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:49:27 "},"ci-cd.html":{"url":"ci-cd.html","title":"CI/CD","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:49:35 "},"service-deployment.html":{"url":"service-deployment.html","title":"服务部署","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:49:55 "},"log-collection.html":{"url":"log-collection.html","title":"日志收集","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:50:01 "},"service-monitor.html":{"url":"service-monitor.html","title":"服务监控","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:50:07 "},"goctl.html":{"url":"goctl.html","title":"Goctl","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:50:13 "},"component-center.html":{"url":"component-center.html","title":"组件中心","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:50:19 "},"tool-center.html":{"url":"tool-center.html","title":"工具中心","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:50:25 "},"intellij.html":{"url":"intellij.html","title":"intellij插件","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:50:31 "},"vscode.html":{"url":"vscode.html","title":"vscode插件","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:50:37 "},"plugin-center.html":{"url":"plugin-center.html","title":"插件中心","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:50:44 "},"learning-resource.html":{"url":"learning-resource.html","title":"学习资源","keywords":"","body":"学习资源 这里将不定期更新go-zero的最新学习资源通道，目前包含通道有： 公众号 Go夜读 Go开源说 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 14:51:29 "},"wechat.html":{"url":"wechat.html","title":"公众号","keywords":"","body":"公众号 微服务实战是go-zero的官方公众号，在这里会发布最新的go-zero最佳实践，同步go夜读、go开源说、GopherChina、腾讯云开发者大会等多渠道关于go-zero的最新技术和资讯。 公众号名称 公众号作者 公众号二维码 微服务实战 kevwan 干货 这里列举一些干货，想要收获更多go-zero最佳实践干货，可以关注公众号获取最新动态。 《一文读懂云原生 go-zero 微服务框架》 《你还在手撕微服务？快试试 go-zero 的微服务自动生成》 《最简单的Go Dockerfile编写姿势，没有之一！》 《通过MapReduce降低服务响应时间》 《微服务过载保护原理与实战 《最简单的 K8S 部署文件编写姿势，没有之一！》 《go-zero 如何应对海量定时/延迟任务？》 《go-zero 如何扛住流量冲击（一）》 《服务自适应降载保护设计》 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 15:06:52 "},"goreading.html":{"url":"goreading.html","title":"Go夜读","keywords":"","body":"Go夜读 2020-08-16 晓黑板 go-zero 微服务框架的架构设计 2020-10-03 go-zero 微服务框架和线上交流 防止缓存击穿之进程内共享调用 基于go-zero实现JWT认证 再见go-micro！企业项目迁移go-zero全攻略（一） Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 15:02:35 "},"gotalk.html":{"url":"gotalk.html","title":"Go开源说","keywords":"","body":"Go开源说 Go 开源说第四期 - Go-Zero Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 15:04:45 "},"dev-log.html":{"url":"dev-log.html","title":"开发日志","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:51:16 "},"goctl-log.html":{"url":"goctl-log.html","title":"goctl开发日志","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:51:22 "},"intellij-log.html":{"url":"intellij-log.html","title":"intellij开发日志","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:51:28 "},"contributor.html":{"url":"contributor.html","title":"社区贡献","keywords":"","body":"社区贡献 作者 kevwan 参与人员(排名不分先后) kingxt anqiansong StevenZack miaogaolin bittoy zhoushuguang Code-Fight xiaowei520 codingfanlt sjatsh knight0zh mywaystay zjbztianya liuximu Alex1996a masonchen2014 YjLeo rcyw voidint wenj91 TonoT foyon defp HappyUncle benyingY cuisongliu yangwenmai weibobo dylanNew WangLeonard Janetyu Jancd microyahoo jiangbohhh chrislee87 supermario1990 ivalue2333 changkun HarryWang29 windk Howie59 wuqinqiang Hkesd almas1992 shenbaise9527 mlboy jichangyun linyihai wwek 注：以上贡献人员为go-zero项目，最后更新于2021年2月5日 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 14:33:54 "},"error.html":{"url":"error.html","title":"常见错误处理","keywords":"","body":"常见错误处理 错误一: pb/xx.pb.go:220:7: undefined: grpc.ClientConnInterface pb/xx.pb.go:224:11: undefined: grpc.SupportPackageIsVersion6 pb/xx.pb.go:234:5: undefined: grpc.ClientConnInterface pb/xx.pb.go:237:24: undefined: grpc.ClientConnInterface 解决方法：请将protoc-gen-go版本降至v1.3.2及一下 错误二: # go.etcd.io/etcd/clientv3/balancer/picker ../../../go/pkg/mod/go.etcd.io/etcd@v0.0.0-20200402134248-51bdeb39e698/clientv3/balancer/picker/err.go:25:9: cannot use &errPicker literal (type *errPicker) as type Picker in return argument:*errPicker does not implement Picker (wrong type for Pick method) have Pick(context.Context, balancer.PickInfo) (balancer.SubConn, func(balancer.DoneInfo), error) want Pick(balancer.PickInfo) (balancer.PickResult, error) ../../../go/pkg/mod/go.etcd.io/etcd@v0.0.0-20200402134248-51bdeb39e698/clientv3/balancer/picker/roundrobin_balanced.go:33:9: cannot use &rrBalanced literal (type *rrBalanced) as type Picker in return argument: *rrBalanced does not implement Picker (wrong type for Pick method) have Pick(context.Context, balancer.PickInfo) (balancer.SubConn, func(balancer.DoneInfo), error) want Pick(balancer.PickInfo) (balancer.PickResult, error) #github.com/tal-tech/go-zero/zrpc/internal/balancer/p2c ../../../go/pkg/mod/github.com/tal-tech/go-zero@v1.0.12/zrpc/internal/balancer/p2c/p2c.go:41:32: not enough arguments in call to base.NewBalancerBuilder have (string, *p2cPickerBuilder) want (string, base.PickerBuilder, base.Config) ../../../go/pkg/mod/github.com/tal-tech/go-zero@v1.0.12/zrpc/internal/balancer/p2c/p2c.go:58:9: cannot use &p2cPicker literal (type *p2cPicker) as type balancer.Picker in return argument: *p2cPicker does not implement balancer.Picker (wrong type for Pick method) have Pick(context.Context, balancer.PickInfo) (balancer.SubConn, func(balancer.DoneInfo), error) want Pick(balancer.PickInfo) (balancer.PickResult, error) 解决方法： replace google.golang.org/grpc => google.golang.org/grpc v1.29.1 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 12:43:05 "},"source.html":{"url":"source.html","title":"相关源码","keywords":"","body":"相关源码 demo源码 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 12:40:04 "}}
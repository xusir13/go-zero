{"./":{"url":"./","title":"简介","keywords":"","body":" go-zero 0. go-zero 介绍 go-zero 是一个集成了各种工程实践的 web 和 rpc 框架。通过弹性设计保障了大并发服务端的稳定性，经受了充分的实战检验。 go-zero 包含极简的 API 定义和生成工具 goctl，可以根据定义的 api 文件一键生成 Go, iOS, Android, Kotlin, Dart, TypeScript, JavaScript 代码，并可直接运行。 使用 go-zero 的好处： 轻松获得支撑千万日活服务的稳定性 内建级联超时控制、限流、自适应熔断、自适应降载等微服务治理能力，无需配置和额外代码 微服务治理中间件可无缝集成到其它现有框架使用 极简的 API 描述，一键生成各端代码 自动校验客户端请求参数合法性 大量微服务治理和并发工具包 1. go-zero 框架背景 18 年初，我们决定从 Java+MongoDB 的单体架构迁移到微服务架构，经过仔细思考和对比，我们决定： 基于 Go 语言 高效的性能 简洁的语法 广泛验证的工程效率 极致的部署体验 极低的服务端资源成本 自研微服务框架 有过很多微服务框架自研经验 需要有更快速的问题定位能力 更便捷的增加新特性 2. go-zero 框架设计思考 对于微服务框架的设计，我们期望保障微服务稳定性的同时，也要特别注重研发效率。所以设计之初，我们就有如下一些准则： 保持简单，第一原则 弹性设计，面向故障编程 工具大于约定和文档 高可用 高并发 易扩展 对业务开发友好，封装复杂度 约束做一件事只有一种方式 我们经历不到半年时间，彻底完成了从 Java+MongoDB 到 Golang+MySQL 为主的微服务体系迁移，并于 18 年 8 月底完全上线，稳定保障了业务后续迅速增长，确保了整个服务的高可用。 3. go-zero 项目实现和特点 go-zero 是一个集成了各种工程实践的包含 web 和 rpc 框架，有如下主要特点： 强大的工具支持，尽可能少的代码编写 极简的接口 完全兼容 net/http 支持中间件，方便扩展 高性能 面向故障编程，弹性设计 内建服务发现、负载均衡 内建限流、熔断、降载，且自动触发，自动恢复 API 参数自动校验 超时级联控制 自动缓存控制 链路跟踪、统计报警等 高并发支撑，稳定保障了疫情期间每天的流量洪峰 如下图，我们从多个层面保障了整体服务的高可用： 觉得不错的话，别忘 star 👏 4. Installation 在项目目录下通过如下命令安装： GO111MODULE=on GOPROXY=https://goproxy.cn/,direct go get -u github.com/tal-tech/go-zero 5. Quick Start 完整示例请查看 快速构建高并发微服务 快速构建高并发微服务 - 多 RPC 版 安装 goctl 工具 goctl 读作 go control，不要读成 go C-T-L。goctl 的意思是不要被代码控制，而是要去控制它。其中的 go 不是指 golang。在设计 goctl 之初，我就希望通过 她 来解放我们的双手👈 GO111MODULE=on GOPROXY=https://goproxy.cn/,direct go get -u github.com/tal-tech/go-zero/tools/goctl 确保 goctl 可执行 快速生成 api 服务 goctl api new greet cd greet go mod init go mod tidy go run greet.go -f etc/greet-api.yaml 默认侦听在 8888 端口（可以在配置文件里修改），可以通过 curl 请求： curl -i http://localhost:8888/from/you 返回如下： HTTP/1.1 200 OK Content-Type: application/json Date: Thu, 22 Oct 2020 14:03:18 GMT Content-Length: 14 {\"message\":\"\"} 编写业务代码： api 文件定义了服务对外暴露的路由，可参考 api 规范 可以在 servicecontext.go 里面传递依赖给 logic，比如 mysql, redis 等 在 api 定义的 get/post/put/delete 等请求对应的 logic 里增加业务处理逻辑 可以根据 api 文件生成前端需要的 Java, TypeScript, Dart, JavaScript 代码 goctl api java -api greet.api -dir greet goctl api dart -api greet.api -dir greet ... 6. Benchmark 测试代码见这里 7. 文档 API 文档 https://www.yuque.com/tal-tech/go-zero awesome 系列（更多文章见『微服务实践』公众号） 快速构建高并发微服务 快速构建高并发微服务 - 多 RPC 版 goctl 使用帮助 精选 goctl 插件 插件 用途 goctl-swagger 一键生成 api 的 swagger 文档 goctl-android 生成 java (android) 端 http client 请求代码 goctl-go-compact 合并 api 里同一个 group 里的 handler 到一个 go 文件 8. 微信公众号 go-zero 相关文章都会在 微服务实践 公众号整理呈现，欢迎扫码关注，也可以通过公众号私信我 👏 9. 微信交流群 如果文档中未能覆盖的任何疑问，欢迎您在群里提出，我们会尽快答复。 您可以在群内提出使用中需要改进的地方，我们会考虑合理性并尽快修改。 如果您发现 bug 请及时提 issue，我们会尽快确认并修改。 为了防止广告用户、识别技术同行，请 star 后加我时注明 github 当前 star 数，我再拉进 go-zero 群，感谢！ 加我之前有劳点一下 star，一个小小的 star 是作者们回答海量问题的动力🤝 项目地址：https://github.com/tal-tech/go-zero 码云地址：https://gitee.com/kevwan/go-zero (国内用户可访问gitee，每日自动从github同步代码) Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 14:46:20 "},"about-us.html":{"url":"about-us.html","title":"关于我们","keywords":"","body":"关于我们 go-zero go-zero 是一个集成了各种工程实践的 web 和 rpc 框架。通过弹性设计保障了大并发服务端的稳定性，经受了充分的实战检验。 go-zero 包含极简的 API 定义和生成工具 goctl，可以根据定义的 api 文件一键生成 Go, iOS, Android, Kotlin, Dart, TypeScript, JavaScript 代码，并可直接运行。 go-zero作者 万俊峰，晓黑板研发负责人，好未来资深技术专家，拥有14年研发团队管理经验，16年架构设计经验，20年工程实战经验，负责过多个大型项目的架构设计，曾多次合伙创业（被收购），GopherChina大会讲师，腾讯云开发者大会讲师。 go-zero成员 go-zero截止2021年2月，目前拥有30人的团队开发人员及50+的社区成员。 go-zero社区 我们目前拥有3000多人的社区成员，在这里，你可以和大家讨论任何关于go-zero的技术，问题反馈，获取最新的go-zero信息，以及各位大佬每天分享的技术心得。 go-zero社区群 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 14:26:36 "},"join-us.html":{"url":"join-us.html","title":"加入我们","keywords":"","body":"加入我们 概要 go-zero 是一个基于MIT License 的开源项目，大家在使用中发现bug，有新的特性等，均可以参与到go-zero的贡献中来，我们非常欢迎大家的积极参与，也会最快响应大家提出的各种问题，pr等。 贡献形式 Pull Request Issue 贡献须知 go-zero 的Pull request中的代码需要满足一定规范 命名规范，请阅读命名规范 以英文注释为主 pr时备注好功能特性，描述需要清晰，简洁 增加单元测试覆盖率达80%+ 贡献代码（pr） 进入go-zero 项目，fork一份go-zero 项目到自己的github仓库中。 回到自己的github主页，找到xx/go-zero项目，其中xx为你的用户名，如anqiansong/go-zero 克隆代码到本地 开发代码，push到自己的github仓库 进入自己的github中go-zero项目，点击浮层上的的【Pull requests】进入Compare页面。 base repository选择tal-tech/go-zero base:master,head repository选择xx/go-zero compare:$branch ，$branch为你开发的分支，如图： 点击【Create pull request】即可实现pr申请 确认pr是否提交成功，进入go-zero 的Pull requests 查看，应该有自己提交的记录，名称为你的开发时的分支名称 Issue 在我们的社区中，有很多伙伴会积极的反馈一些go-zero使用过程中遇到的问题，由于社区人数较多，我们虽然会实时的关注社区动态，但大家问题反馈过来都是随机的，当我们团队还在解决某一个伙伴提出的问题时，另外的问题也反馈上来，可能会导致团队会很容易忽略掉，为了能够一一的解决大家的问题，我们强烈建议大家通过issue的方式来反馈问题，包括但不限于bug，期望的新功能特性等，我们在实现某一个新特性时也会在issue中体现，大家在这里也能够在这里获取到go-zero的最新动向，也欢迎大家来积极的参与讨论。 怎么提Issue 点击这里 进入go-zero的Issue页面或者直接访问https://github.com/tal-tech/go-zero/issues 地址 点击右上角的【New issue】新建issue 填写issue标题和内容 点击【Submit new issue】提交issue 参考文档 Pull request Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 14:46:20 "},"concept-introduction.html":{"url":"concept-introduction.html","title":"概念介绍","keywords":"","body":"概念介绍 go-zero 晓黑板golang开源项目，集各种工程实践于一身的web和rpc框架。 goctl 一个旨在为开发人员提高工程效率、降低出错率的辅助工具。 goctl插件 指以goctl为中心的周边二进制资源，能够满足一些个性化的代码生成需求，如路由合并插件goctl-go-compact插件， 生成swagger文档的goctl-swagger插件，生成php调用端的goctl-php插件等。 intellij/vscode插件 在intellij系列产品上配合goctl开发的插件，其将goctl命令行操作使用UI进行替代。 api文件 api文件是指用于定义和描述api服务的文本文件，其以.api后缀结尾，包含api语法描述内容。 goctl环境 goctl环境是使用goctl前的准备环境，包含 golang环境 protoc protoc-gen-go插件 go module | gopath go-zero-demo go-zero-demo里面包含了文档中所有源码的一个大仓库，后续我们在编写演示demo时，我们均在此项目下创建子项目， 因此我们需要提前创建一个大仓库go-zero-demo，我这里把这个仓库放在home目录下。 $ cd ~ $ mkdir go-zero-demo&&cd go-zero-demo $ go mod init go-zero-demo 参考文档 go-zero Goctl 插件中心 工具中心 api语法 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 12:07:00 "},"quick-start.html":{"url":"quick-start.html","title":"快速开发","keywords":"","body":"快速开发 本节主要通过对api/rpc等服务快速开始来让大家对使用go-zero开发的工程有一个宏观概念， 对于更加详细的介绍我们将在后续一一展开，本节将包含一下小节： 单体服务 微服务 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 23:27:45 "},"monolithic-service.html":{"url":"monolithic-service.html","title":"单体服务","keywords":"","body":"单体服务 前言 由于go-zero集成了web/rpc于一体，社区有部分小伙伴会问我，go-zero的定位是否是一款微服务框架， 答案是否定的，go-zero虽然集众多功能于一身，但你可以将其中任何一个功能独立出来去单独使用，也可以开发单体服务， 不是说每个服务上来就一定要采用微服务的架构的设计，这点大家可以看看作者(kevin)的第四期开源说 ，其中对此有详细的讲解。 创建greet服务 $ cd ~/go-zero-demo $ goctl api new greet Done. 查看一下greet服务的结构 $ cd greet $ tree . ├── etc │ └── greet-api.yaml ├── go.mod ├── greet.api ├── greet.go └── internal ├── config │ └── config.go ├── handler │ ├── greethandler.go │ └── routes.go ├── logic │ └── greetlogic.go ├── svc │ └── servicecontext.go └── types └── types.go 由以上目录结构可以观察到，greet服务虽小，但\"五脏俱全\"。接下来我们就可以在greetlogic.go中编写业务代码了。 编写逻辑 $ vim ~/go-zero-demo/greet/internal/logic/greetlogic.go func (l *GreetLogic) Greet(req types.Request) (*types.Response, error) { return &types.Response{ Message: \"Hello go-zero\", }, nil } 启动并访问服务 启动服务 $ cd ~/go-zer-demo/greet $ go run greet.go -f etc/greet-api.yaml Starting server at 0.0.0.0:8888... 访问服务 $ curl -i -X GET \\ http://localhost:8888/from/you HTTP/1.1 200 OK Content-Type: application/json Date: Sun, 07 Feb 2021 04:31:25 GMT Content-Length: 27 {\"message\":\"Hello go-zero\"} 源码 greet源码 猜你想看 goctl使用说明 api目录结构介绍 api语法 api配置文件介绍 api中间件使用 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 12:45:19 "},"micro-service.html":{"url":"micro-service.html","title":"微服务","keywords":"","body":"微服务 在上一篇我们已经演示了怎样快速创建一个单体服务，接下来我们来演示一下如何快速创建微服务， 在本小节中，api部分其实和单体服务的创建逻辑是一样的，只是在单体服务中没有服务间的通讯而已， 且微服务中api服务会多一些rpc调用的配置。 前言 本小节将以一个订单服务调用用户服务来简单演示一下，演示代码仅传递思路，其中有些环节不会一一列举。 情景提要 假设我们在开发一个商城项目，而开发者小明负责用户模块(user)和订单模块(order)的开发，我们姑且将这两个模块拆分成两个微服务① [!NOTE] ①：微服务的拆分也是一门学问，这里我们就不讨论怎么去拆分微服务的细节了。 演示功能目标 订单服务(order)提供一个查询接口 用户服务(user)提供一个方法供订单服务获取用户信息 服务设计分析 根据情景提要我们可以得知，订单是直接面向用户，通过http协议访问数据，而订单内部需要获取用户的一些基础数据，既然我们的服务是采用微服务的架构设计， 那么两个服务（user,order）就必须要进行数据交换，服务间的数据交换即服务间的通讯，到了这里，采用合理的通讯协议也是一个开发人员需要 考虑的事情，可以通过http，rpc等方式来进行通讯，这里我们选择rpc来实现服务间的通讯，相信这里我已经对\"rpc服务存在有什么作用？\"已经作了一个比较好的场景描述。 当然，一个服务开发前远不止这点设计分析，我们这里就不详细描述了。从上文得知，我们需要一个 user rpc order api 两个服务来初步实现这个小demo。 创建mall工程 $ cd ~/go-zero-demo $ mkdir mall && cd mall 创建user rpc服务 创建user rpc服务 $ cd ~/go-zero-demo/mall $ mkdir -p user/rpc&&cd user/rpc 添加user.proto文件，增加getUser方法 $ vim ~/go-zero-demo/mall/user/user.proto syntax = \"proto3\"; package user; message IdRequest { string id = 1; } message UserResponse { // 用户id string id = 1; // 用户名称 string name = 2; // 用户性别 string gender = 3; } service User { rpc getUser(IdRequest) returns(UserResponse); } 生成代码 $ cd ~/go-zero-demo/mall/user/rpc $ goctl rpc proto -src user.proto -dir . protoc -I=/Users/xx/mall/user user.proto --go_out=plugins=grpc:/Users/xx/mall/user/user Done. 填充业务逻辑 $ vim vi internal/logic/getuserlogic.go package logic import ( \"context\" \"go-zero-demo/mall/user/internal/svc\" \"go-zero-demo/mall/user/user\" \"github.com/tal-tech/go-zero/core/logx\" ) type GetUserLogic struct { ctx context.Context svcCtx *svc.ServiceContext logx.Logger } func NewGetUserLogic(ctx context.Context, svcCtx *svc.ServiceContext) *GetUserLogic { return &GetUserLogic{ ctx: ctx, svcCtx: svcCtx, Logger: logx.WithContext(ctx), } } func (l *GetUserLogic) GetUser(in *user.IdRequest) (*user.UserResponse, error) { return &user.UserResponse{ Id: \"1\", Name: \"test\", }, nil } 创建order api服务 创建 order api服务 $ cd ~/go-zero-demo/mall $ mkdir -p order/api&&cd order/api 添加api文件 $ vim order.api type( OrderReq { Id string `path:\"id\"` } OrderReply { Id string `json:\"id\"` Name string `json:\"name\"` } ) service order { @handler getOrder get /api/order/get/:id (OrderReq) returns (OrderReply) } 生成order服务 $ goctl api go -api order.api -dir . Done. 添加user rpc配置 $ vim internal/config/config.go package config import \"github.com/tal-tech/go-zero/rest\" import \"github.com/tal-tech/go-zero/zrpc\" type Config struct { rest.RestConf UserRpc zrpc.RpcClientConf } 添加yaml配置 $ vim etc/order.yaml Name: order Host: 0.0.0.0 Port: 8888 UserRpc: Etcd: Hosts: - 127.0.0.1:2379 Key: user.rpc 完善服务依赖 $ vim internal/svc/servicecontext.go package svc import ( \"go-zero-demo/mall/order/api/internal/config\" \"go-zero-demo/mall/user/rpc/userclient\" \"github.com/tal-tech/go-zero/zrpc\" ) type ServiceContext struct { Config config.Config UserRpc userclient.User } func NewServiceContext(c config.Config) *ServiceContext { return &ServiceContext{ Config: c, UserRpc: userclient.NewUser(zrpc.MustNewClient(c.UserRpc)), } } 添加order演示逻辑 给getorderlogic添加业务逻辑 $ vim ~/go-zero-demo/mall/order/api/internal/logic/getorderlogic.go user, err := l.svcCtx.UserRpc.GetUser(l.ctx, &userclient.IdRequest{ Id: \"1\", }) if err != nil { return nil, err } if user.Name != \"test\" { return nil, errors.New(\"用户不存在\") } return &types.OrderReply{ Id: req.Id, Name: \"test order\", }, nil 启动服务并验证 启动etcd$ etcd 启动user rpc$ go run user.go -f etc/user.yaml Starting rpc server at 127.0.0.1:8080... [!TIP] 如果启动报类似not enough arguments in call to base.NewBalancerBuilder的错误，请查阅常见错误处理 启动order api$ go run order.go -f etc/order.yaml Starting server at 0.0.0.0:8888... 访问order api curl -i -X GET \\ http://localhost:8888/api/order/get/1 HTTP/1.1 200 OK Content-Type: application/json Date: Sun, 07 Feb 2021 03:45:05 GMT Content-Length: 30 {\"id\":\"1\",\"name\":\"test order\"} [!TIP] 在演示中的提及的api语法，rpc生成，goctl，goctl环境等怎么使用和安装，快速入门中不作详细概述，我们后续都会有详细的文档进行描述，你也可以点击下文的【猜你想看】快速跳转的对应文档查看。 源码 mall源码 猜你想看 goctl使用说明 api目录结构介绍 api语法 api配置文件介绍 api中间件使用 rpc目录 rpc配置 rpc调用方说明 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 12:45:19 "},"framework-design.html":{"url":"framework-design.html","title":"框架设计","keywords":"","body":"框架设计 本节将从go-zero的设计理念，go-zerp服务的最佳实践目录来说明go-zero框架的设计，本节将包含以下小节： go-zero设计理念 api语法介绍 api目录结构 rpc目录结构 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 14:12:01 "},"go-zero-design.html":{"url":"go-zero-design.html","title":"go-zero设计理念","keywords":"","body":"go-zero设计理念 对于微服务框架的设计，我们期望保障微服务稳定性的同时，也要特别注重研发效率。所以设计之初，我们就有如下一些准则： 保持简单，第一原则 弹性设计，面向故障编程 工具大于约定和文档 高可用 高并发 易扩展 对业务开发友好，封装复杂度 约束做一件事只有一种方式 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 13:38:52 "},"go-zero-features.html":{"url":"go-zero-features.html","title":"go-zero特点","keywords":"","body":"go-zero特性 go-zero 是一个集成了各种工程实践的包含 web 和 rpc 框架，有如下主要特点： 强大的工具支持，尽可能少的代码编写 极简的接口 完全兼容 net/http 支持中间件，方便扩展 高性能 面向故障编程，弹性设计 内建服务发现、负载均衡 内建限流、熔断、降载，且自动触发，自动恢复 API 参数自动校验 超时级联控制 自动缓存控制 链路跟踪、统计报警等 高并发支撑，稳定保障了疫情期间每天的流量洪峰 如下图，我们从多个层面保障了整体服务的高可用： Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 14:32:57 "},"api-grammar.html":{"url":"api-grammar.html","title":"api语法介绍","keywords":"","body":"api语法介绍 api示例 /** * api语法示例及语法说明 */ // api语法版本 syntax = \"v1\" // import literal import \"foo.api\" // import group import ( \"bar.api\" \"foo/bar.api\" ) info( author: \"songmeizi\" date: \"2020-01-08\" desc: \"api语法示例及语法说明\" ) // type literal type Foo{ Foo int `json:\"foo\"` } // type group type( Bar{ Bar int `json:\"bar\"` } ) // service block @server( jwt: Auth group: foo ) service foo-api{ @doc \"foo\" @handler foo post /foo (Foo) returns (Bar) } api语法结构 syntax语法声明 import语法块 info语法块 type语法块 service语法块 隐藏通道 [!TIP] 在以上语法结构中，各个语法块从语法上来说，按照语法块为单位，可以在.api文件中任意位置声明， 但是为了提高阅读效率，我们建议按照以上顺序进行声明，因为在将来可能会通过严格模式来控制语法块的顺序。 syntax语法声明 syntax是新加入的语法结构，该语法的引入可以解决： 快速针对api版本定位存在问题的语法结构 针对版本做语法解析 防止api语法大版本升级导致前后不能向前兼容 **[!WARNING] 被import的api必须要和main api的syntax版本一致。 语法定义 'syntax'={checkVersion(p)}STRING 语法说明 syntax：固定token，标志一个syntax语法结构的开始 checkVersion：自定义go方法，检测STRING是否为一个合法的版本号，目前检测逻辑为，STRING必须是满足(?m)\"v[1-9][0-9]*\"正则。 STRING：一串英文双引号包裹的字符串，如\"v1\" 一个api语法文件只能有0或者1个syntax语法声明，如果没有syntax，则默认为v1版本 正确语法示例 ✅ eg1：不规范写法 syntax=\"v1\" eg2：规范写法(推荐) syntax = \"v2\" 错误语法示例 ❌ eg1： syntax = \"v0\" eg2： syntax = v1 eg3： syntax = \"V1\" import语法块 随着业务规模增大，api中定义的结构体和服务越来越多，所有的语法描述均为一个api文件，这是多么糟糕的一个问题， 其会大大增加了阅读难度和维护难度，import语法块可以帮助我们解决这个问题，通过拆分api文件， 不同的api文件按照一定规则声明，可以降低阅读难度和维护难度。 **[!WARNING] 这里import不像golang那样包含package声明，仅仅是一个文件路径的引入，最终解析后会把所有的声明都汇聚到一个spec.Spec中。 不能import多个相同路径，否则会解析错误。 语法定义 'import' {checkImportValue(p)}STRING |'import' '(' ({checkImportValue(p)}STRING)+ ')' 语法说明 import：固定token，标志一个import语法的开始 checkImportValue：自定义go方法，检测STRING是否为一个合法的文件路径，目前检测逻辑为，STRING必须是满足(?m)\"(/?[a-zA-Z0-9_#-])+\\.api\"正则。 STRING：一串英文双引号包裹的字符串，如\"foo.api\" 正确语法示例 ✅ eg： import \"foo.api\" import \"foo/bar.api\" import( \"bar.api\" \"foo/bar/foo.api\" ) 错误语法示例 ❌ eg： import foo.api import \"foo.txt\" import ( bar.api bar.api ) info语法块 info语法块是一个包含了多个键值对的语法体，其作用相当于一个api服务的描述，解析器会将其映射到spec.Spec中， 以备用于翻译成其他语言(golang、java等) 时需要携带的meta元素。如果仅仅是对当前api的一个说明，而不考虑其翻译 时传递到其他语言，则使用简单的多行注释或者java风格的文档注释即可，关于注释说明请参考下文的 隐藏通道。 **[!WARNING] 不能使用重复的key，每个api文件只能有0或者1个info语法块 语法定义 'info' '(' (ID {checkKeyValue(p)}VALUE)+ ')' 语法说明 info：固定token，标志一个info语法块的开始 checkKeyValue：自定义go方法，检测VALUE是否为一个合法值。 VALUE：key对应的值，可以为单行的除'\\r','\\n','/'后的任意字符，多行请以\"\"包裹，不过强烈建议所有都以\"\"包裹 正确语法示例 ✅ eg1：不规范写法 info( foo: foo value bar:\"bar value\" desc:\"long long long long long long text\" ) eg2：规范写法(推荐) info( foo: \"foo value\" bar: \"bar value\" desc: \"long long long long long long text\" ) 错误语法示例 ❌ eg1：没有key-value内容 info() eg2：不包含冒号 info( foo value ) eg3：key-value没有换行 info(foo:\"value\") eg4：没有key info( : \"value\" ) eg5：非法的key info( 12: \"value\" ) eg6：移除旧版本多行语法 info( foo: > some text type语法块 在api服务中，我们需要用到一个结构体(类)来作为请求体，响应体的载体，因此我们需要声明一些结构体来完成这件事情， type语法块由golang的type演变而来，当然也保留着一些golang type的特性，沿用golang特性有： 保留了golang内置数据类型bool,int,int8,int16,int32,int64,uint,uint8,uint16,uint32,uint64,uintptr ,float32,float64,complex64,complex128,string,byte,rune, 兼容golang struct风格声明 保留golang关键字 **[!WARNING]️ 不支持alias 不支持time.Time数据类型 结构体名称、字段名称、不能为golang关键字 语法定义 由于其和golang相似，因此不做详细说明，具体语法定义请在ApiParser.g4中查看typeSpec定义。 语法说明 参考golang写法 正确语法示例 ✅ eg1：不规范写法 type Foo struct{ Id int `path:\"id\"` // ① Foo int `json:\"foo\"` } type Bar struct{ // 非导出型字段 bar int `form:\"bar\"` } type( // 非导出型结构体 fooBar struct{ FooBar int } ) eg2：规范写法（推荐） type Foo{ Id int `path:\"id\"` Foo int `json:\"foo\"` } type Bar{ Bar int `form:\"bar\"` } type( FooBar{ FooBar int } ) 错误语法示例 ❌ eg type Gender int // 不支持 // 非struct token type Foo structure{ CreateTime time.Time // 不支持time.Time } // golang关键字 var type var{} type Foo{ // golang关键字 interface Foo interface } type Foo{ foo int // map key必须要golang内置数据类型 m map[Bar]string } [!NOTE] ① tag定义和golang中json tag语法一样，除了json tag外，go-zero还提供了另外一些tag来实现对字段的描述， 详情见下表。 tag表 tag key 描述 提供方有效范围 示例 json json序列化tag golang request、response json:\"fooo\" path 路由path，如/foo/:id go-zero request path:\"id\" form 标志请求体是一个form（POST方法时）或者一个query(GET方法时/search?name=keyword) go-zero request form:\"name\" tag修饰符 常见参数校验描述 tag key 描述 提供方 有效范围 示例 optional 定义当前字段为可选参数 go-zero request json:\"name,optional\" options 定义当前字段的枚举值,多个以竖线|隔开 go-zero request json:\"gender,options=male\" default 定义当前字段默认值 go-zero request json:\"gender,default=male\" range 定义当前字段数值范围 go-zero request json:\"age,range=[0:120]\" [!TIP] tag修饰符需要在tag value后以引文逗号,隔开 service语法块 service语法块用于定义api服务，包含服务名称，服务metadata，中间件声明，路由，handler等。 **[!WARNING]️ main api和被import的api服务名称必须一致，不能出现服务名称歧义。 handler名称不能重复 路由（请求方法+请求path）名称不能重复 请求体必须声明为普通（非指针）struct，响应体做了一些向前兼容处理，详请见下文说明 语法定义 serviceSpec: atServer? serviceApi; atServer: '@server' lp='(' kvLit+ rp=')'; serviceApi: {match(p,\"service\")}serviceToken=ID serviceName lbrace='{' serviceRoute* rbrace='}'; serviceRoute: atDoc? (atServer|atHandler) route; atDoc: '@doc' lp='('? ((kvLit+)|STRING) rp=')'?; atHandler: '@handler' ID; route: {checkHttpMethod(p)}httpMethod=ID path request=body? returnToken=ID? response=replybody?; body: lp='(' (ID)? rp=')'; replybody: lp='(' dataType? rp=')'; // kv kvLit: key=ID {checkKeyValue(p)}value=LINE_VALUE; serviceName: (ID '-'?)+; path: (('/' (ID ('-' ID)*))|('/:' (ID ('-' ID)?)))+; 语法说明 serviceSpec：包含了一个可选语法块atServer和serviceApi语法块，其遵循序列模式（编写service必须要按照顺序，否则会解析出错） atServer： 可选语法块，定义key-value结构的server metadata，'@server' 表示这一个server语法块的开始，其可以用于描述serviceApi或者route语法块，其用于描述不同语法块时有一些特殊关键key 需要值得注意，见 atServer关键key描述说明。 serviceApi：包含了1到多个serviceRoute语法块 serviceRoute：按照序列模式包含了atDoc,handler和route atDoc：可选语法块，一个路由的key-value描述，其在解析后会传递到spec.Spec结构体，如果不关心传递到spec.Spec, 推荐用单行注释替代。 handler：是对路由的handler层描述，可以通过atServer指定handler key来指定handler名称， 也可以直接用atHandler语法块来定义handler名称 atHandler：'@handler' 固定token，后接一个遵循正则[_a-zA-Z][a-zA-Z_-]*)的值，用于声明一个handler名称 route：路由，有httpMethod、path、可选request、可选response组成，httpMethod是必须是小写。 body：api请求体语法定义，必须要由()包裹的可选的ID值 replyBody：api响应体语法定义，必须由()包裹的struct、array(向前兼容处理，后续可能会废弃，强烈推荐以struct包裹，不要直接用array作为响应体) kvLit： 同info key-value serviceName: 可以有多个'-'join的ID值 path：api请求路径，必须以'/'或者'/:'开头，切不能以'/'结尾，中间可包含ID或者多个以'-'join的ID字符串 atServer关键key描述说明 修饰service时 key描述示例 jwt声明当前service下所有路由需要jwt鉴权，且会自动生成包含jwt逻辑的代码jwt: Auth group声明当前service或者路由文件分组group: login middleware声明当前service需要开启中间件middleware: AuthMiddleware 修饰route时 key描述示例 handler声明一个handler- 正确语法示例 ✅ eg1：不规范写法 @server( jwt: Auth group: foo middleware: AuthMiddleware ) service foo-api{ @doc( summary: foo ) @server( handler: foo ) // 非导出型body post /foo/:id (foo) returns (bar) @doc \"bar\" @handler bar post /bar returns ([]int)// 不推荐数组作为响应体 @handler fooBar post /foo/bar (Foo) returns // 可以省略'returns' } eg2：规范写法（推荐） @server( jwt: Auth group: foo middleware: AuthMiddleware ) service foo-api{ @doc \"foo\" @handler: foo post /foo/:id (Foo) returns (Bar) } service foo-api{ @handler ping get /ping @doc \"foo\" @handler: bar post /bar/:id (Foo) } 错误语法示例 ❌ // 不支持空的server语法块 @server( ) // 不支持空的service语法块 service foo-api{ } service foo-api{ @doc kkkk // 简版doc必须用英文双引号引起来 @handler foo post /foo @handler foo // 重复的handler post /bar @handler fooBar post /bar // 重复的路由 // @handler和@doc顺序错误 @handler someHandler @doc \"some doc\" post /some/path // handler缺失 post /some/path/:id @handler reqTest post /foo/req (*Foo) // 不支持除普通结构体外的其他数据类型作为请求体 @handler replyTest post /foo/reply returns (*Foo) // 不支持除普通结构体、数组(向前兼容，后续考虑废弃)外的其他数据类型作为响应体 } 隐藏通道 隐藏通道目前主要为空百符号，换行符号以及注释，这里我们只说注释，因为空白符号和换行符号我们目前拿来也无用。 单行注释 语法定义 '//' ~[\\r\\n]* 语法说明 由语法定义可知道，单行注释必须要以//开头，内容为不能包含换行符 正确语法示例 ✅ // doc // comment 错误语法示例 ❌ // break line comments java风格文档注释 语法定义 '/*' .*? '*/' 语法说明 由语法定义可知道，单行注释必须要以/*开头，*/结尾的任意字符。 正确语法示例 ✅ /** * java-style doc */ 错误语法示例 ❌ /* * java-style doc */ */ Doc&Comment 如果想获取某一个元素的doc或者comment开发人员需要怎么定义？ Doc 我们规定上一个语法块（非隐藏通道内容）的行数line+1到当前语法块第一个元素前的所有注释(当行，或者多行)均为doc， 且保留了//、/*、*/原始标记。 Comment 我们规定当前语法块最后一个元素所在行开始的一个注释块(当行，或者多行)为comment 且保留了//、/*、*/原始标记。 语法块Doc和Comment的支持情况 语法块parent语法块DocComment syntaxLitapi✅✅ kvLitinfoSpec✅✅ importLitimportSpec✅✅ typeLitapi✅❌ typeLittypeBlock✅❌ fieldtypeLit✅✅ key-valueatServer✅✅ atHandlerserviceRoute✅✅ routeserviceRoute✅✅ 以下为对应语法块解析后细带doc和comment的写法 // syntaxLit doc syntax = \"v1\" // syntaxLit commnet info( // kvLit doc author: songmeizi // kvLit comment ) // typeLit doc type Foo {} type( // typeLit doc Bar{} FooBar{ // filed doc Name int // filed comment } ) @server( /** * kvLit doc * 开启jwt鉴权 */ jwt: Auth /**kvLit comment*/ ) service foo-api{ // atHandler doc @handler foo //atHandler comment /* * route doc * post请求 * path为 /foo * 请求体：Foo * 响应体：Foo */ post /foo (Foo) returns (Foo) // route comment } Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 14:20:33 "},"api-dir.html":{"url":"api-dir.html","title":"api目录结构","keywords":"","body":"api目录介绍 . ├── etc │ └── greet-api.yaml // 配置文件 ├── go.mod // mod文件 ├── greet.api // api描述文件 ├── greet.go // main函数入口 └── internal ├── config │ └── config.go // 配置声明type ├── handler // 路由及handler转发 │ ├── greethandler.go │ └── routes.go ├── logic // 业务逻辑 │ └── greetlogic.go ├── middleware // 中间件文件 │ └── greetmiddleware.go ├── svc // logic所依赖的资源池 │ └── servicecontext.go └── types // request、response的struct，根据api自动生成，不建议编辑 └── types.go Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 14:07:09 "},"rpc-dir.html":{"url":"rpc-dir.html","title":"rpc目录结构","keywords":"","body":"rpc服务目录 . ├── etc // yaml配置文件 │ └── greet.yaml ├── go.mod ├── greet // pb.go文件夹① │ └── greet.pb.go ├── greet.go // main函数 ├── greet.proto // proto 文件 ├── greetclient // call logic ② │ └── greet.go └── internal ├── config // yaml配置对应的实体 │ └── config.go ├── logic // 业务代码 │ └── pinglogic.go ├── server // rpc server │ └── greetserver.go └── svc // 依赖资源 └── servicecontext.go [!TIP] ① pb文件夹名（老版本文件夹固定为pb）称取自于proto文件中option go_package的值最后一层级按照一定格式进行转换，若无此声明，则取自于package的值，大致代码如下： if option.Name == \"go_package\" { ret.GoPackage = option.Constant.Source } ... if len(ret.GoPackage) == 0 { ret.GoPackage = ret.Package.Name } ret.PbPackage = GoSanitized(filepath.Base(ret.GoPackage)) ... [!TIP] GoSanitized方法请参考google.golang.org/protobuf@v1.25.0/internal/strs/strings.go:71 [!TIP] ② call 层文件夹名称取自于proto中service的名称，如该sercice的名称和pb文件夹名称相等，则会在srervice后面补充client进行区分，使pb和call分隔。 if strings.ToLower(proto.Service.Name) == strings.ToLower(proto.GoPackage) { callDir = filepath.Join(ctx.WorkDir, strings.ToLower(stringx.From(proto.Service.Name+\"_client\").ToCamel())) } Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 14:09:55 "},"project-dev.html":{"url":"project-dev.html","title":"项目开发","keywords":"","body":"项目开发 在前面的章节我们已经从一些概念、背景、快速入门等维度介绍了一下go-zero，看到这里，相信你对go-zero已经有了一些了解， 从这里开始，我们将会从环境准备到服务部署整个流程开始进行讲解，为了保证大家能够彻底弄懂go-zero的开发流程，那就准备你的耐心来接着往下走吧。 在章节中，将包含以下小节： 准备工作 golang安装 go modudle配置 goctl安装 protoc&protoc-gen-go安装 其他 开发规范 命名规范 路由规范 编码规范 开发流程 配置介绍 api配置 rpc配置 业务开发 目录拆分 model生成 api文件编写 业务编码 jwt鉴权 中间件使用 rpc调用 错误处理 服务启动 CI/CD 服务部署 日志收集 服务监控 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-09 10:02:51 "},"prepare.html":{"url":"prepare.html","title":"准备工作","keywords":"","body":"准备工作 在正式进入实际开发之前，我们需要做一些准备工作，比如：Go环境的安装，grpc代码生成使用的工具安装， 必备工具Goctl的安装，Golang环境配置等，本节将包含以下小节： golang安装 go modudle配置 goctl安装 protoc&protoc-gen-go安装 其他 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 15:51:15 "},"golang-install.html":{"url":"golang-install.html","title":"golang安装","keywords":"","body":"Golang环境安装 前言 开发golang程序，必然少不了对其环境的安装，我们这里选择以1.15.1为例。 官方文档 https://golang.google.cn/doc/install mac OS安装Go 下载并安装Go for Mac 验证安装结果 $ go version go version go1.15.1 darwin/amd64 linux 安装Go 下载Go for Linux 解压压缩包至/usr/local $ tar -C /usr/local -xzf go1.15.8.linux-amd64.tar.gz 添加/usr/local/go/bin到环境变量 $ $HOME/.profile export PATH=$PATH:/usr/local/go/bin $ source $HOME/.profile 验证安装结果 $ go version go version go1.15.1 linux/amd64 Windows安装Go 下载并安装Go for Windows 验证安装结果 $ go version go version go1.15.1 windows/amd64 其他 更多操作系统安装见https://golang.org/dl/ Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 15:51:15 "},"gomod-config.html":{"url":"gomod-config.html","title":"go modudle配置","keywords":"","body":"Go Module设置 Go Module介绍 Modules are how Go manages dependencies.[1] 即Go Module是Golang管理依赖性的方式，像Java中的Maven，Android中的Gradle类似。 MODULE配置 查看GO111MODULE开启情况 $ go env GO111MODULE on 开启GO111MODULE，如果已开启（即执行go env GO111MODULE结果为on）请跳过。 $ go env -w GO111MODULE=\"on\" 设置GOPROXY $ go env -w GOPROXY=https://goproxy.cn 设置GOMODCACHE 查看GOMODCACHE $ go env GOMODCACHE 如果目录不为空或者/dev/null，请跳过。 go env -w GOMODCACHE=$GOPATH/pkg/mod 参考文档 [1] Go Modules Reference Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 16:26:46 "},"goctl-install.html":{"url":"goctl-install.html","title":"goctl安装","keywords":"","body":"Goctl安装 前言 Goctl在go-zero项目开发着有着很大的作用，其可以有效的帮助开发者大大提高开发效率，减少代码的出错率，缩短业务开发的工作量，更多的Goctl的介绍请阅读Goctl介绍, 在这里我们强烈推荐大家安装，因为后续演示例子中我们大部分都会以goctl进行演示。 安装(mac&linux) download&install GO111MODULE=on GOPROXY=https://goproxy.cn/,direct go get -u github.com/tal-tech/go-zero 环境变量检测 go get下载编译后的二进制文件位于$GOPATH/bin目录下，要确保$GOPATH/bin已经添加到环境变量。 $ sudo vim /etc/paths 在最后一行添加如下内容 $GOPATH/bin [!TIP] $GOPATH为你本机上的文件地址 安装结果验证 $ goctl -v goctl version 1.1.4 darwin/amd64 [!TIP] windows用户添加环境变量请自行google Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 16:23:34 "},"protoc-install.html":{"url":"protoc-install.html","title":"protoc&protoc-gen-go安装","keywords":"","body":"protoc&protoc-gen-go安装 前言 protoc是一款用C++编写的工具，其可以将proto文件翻译为指定语言的，在go-zero的微服务中，我们采用grpc进行服务间的通信，而grpc的编写就需要用到protoc和翻译成go语言rpc stub代码的插件protoc-gen-go。 本文演示环境 mac OS protoc 3.14.0 protoc安装 进入protobuf release 页面，选择适合自己操作系统的压缩包文件 解压protoc-3.14.0-osx-x86_64.zip并进入protoc-3.14.0-osx-x86_64 $ cd protoc-3.14.0-osx-x86_64/bin 将启动的protoc二进制文件移动到被添加到环境变量的任意path下，如$GOPATH/bin，这里不建议直接将其和系统的一下path放在一起。 $ mv protoc $GOPATH/bin [!TIP] $GOPATH为你本机的实际文件夹地址 验证安装结果 $ protoc --version libprotoc 3.14.0 protoc-gen-go安装 下载安装protoc-gen-go $ go get -u github.com/golang/protobuf/protoc-gen-go go: found github.com/golang/protobuf/protoc-gen-go in github.com/golang/protobuf v1.4.3 go: google.golang.org/protobuf upgrade => v1.25.0 将protoc-gen-go移动到被添加环境变量的任意path下，如$GOPATH/bin，由于go get后的二进制本身就在$GOPATH/bin目录中，因此只要确保你的$GOPATH/bin在环境变量即可。 **[!WARNING] protoc-gen-go安装失败请阅读常见错误处理 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 16:56:07 "},"prepare-other.html":{"url":"prepare-other.html","title":"其他","keywords":"","body":"其他 在之前我们已经对Go环境、Go Module配置、Goctl、protoc&protoc-gen-go安装准备就绪，这些是开发人员在开发阶段必须要准备的环境，而接下来的环境你可以选择性的安装， 因为这些环境一般存在于服务器（安装工作运维会替你完成），但是为了后续演示流程能够完整走下去，我建议大家在本地也安装一下，因为我们的演示环境大部分会以本地为主。 一下仅给出了需要的准备工作，不以文档篇幅作详细介绍了。 其他环境 etcd redis mysql Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-08 15:48:43 "},"dev-specification.html":{"url":"dev-specification.html","title":"开发规范","keywords":"","body":"开发规范 在实际业务开发中，除了要提高业务开发效率，缩短业务开发周期，保证线上业务高性能，高可用的指标外，好的编程习惯也是一个开发人员基本素养之一，在本章节， 我们将介绍一下go-zero中的编码规范，本章节为可选章节，内容仅供交流与参考，本章节将从一下小节进行说明： 命名规范 路由规范 编码规范 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 17:17:51 "},"naming-spec.html":{"url":"naming-spec.html","title":"命名规范","keywords":"","body":"命名规范 在任何语言开发中，都有其语言领域的一些命名规范，这可以帮助团队 降低代码阅读成本 降低维护难度 降低代码复杂度 规范建议 在我们实际开发中，有很多开发人可能是由某一语言转到另外一个语言领域，在转到另外一门语言后， 我们都会保留着对旧语言的编程习惯，在这里，我建议的是，虽然不同语言之前的某些规范可能是相通的， 但是我们最好能够按照官方的一些demo来熟悉是渐渐适应当前语言的编程规范，而不是直接将原来语言的编程规范也随之迁移过来。 文件命名规范 全部小写 出unit test外避免下划线(_) 文件名称不宜过程 变量命名规范参考 首字母小写 驼峰命名 见名知义，避免拼音替代英文 不建议包含下划线(_) 不建议包含数字 适用范围 局部变量 函数出参、入参 函数、常量命名规范 驼峰式命名 可exported的必须首字母大写 不可exported的必须首字母小写 避免全部大写与下划线(_)组合 [!TIP] 如果是go-zero代码贡献，则必须严格遵循此命名规范 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 18:17:19 "},"route-naming-spec.html":{"url":"route-naming-spec.html","title":"路由规范","keywords":"","body":"路由规范 推荐脊柱式命名 小写单词、横杠(-)组合 见名知义 /user/get-info /user/get/info /user/password/change/:id Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-08 09:34:41 "},"coding-spec.html":{"url":"coding-spec.html","title":"编码规范","keywords":"","body":"编码规范 import 单行import不建议用圆括号包裹 按照官方包，NEW LINE，当前工程包，NEW LINE，第三方依赖包顺序引入 import ( \"context\" \"string\" \"greet/user/internal/config\" \"google.golang.org/grpc\" ) 函数返回 对象避免非指针返回 遵循有正常值返回则一定无error，有error则一定无正常值返回的原则 错误处理 有error必须处理，如果不能处理就必须抛出。 避免下划线(_)接收error 函数体编码 建议一个block结束空一行，如if、for等 func main (){ if x==1{ // do something } fmt.println(\"xxx\") } return前空一行 func getUser(id string)(string,error){ .... return \"xx\",nil } Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 18:19:33 "},"dev-flow.html":{"url":"dev-flow.html","title":"开发流程","keywords":"","body":"开发流程 这里的开发流程和我们实际业务开发流程不是一个概念，这里的定义局限于go-zero的使用，即代码层面的开发细节。 开发流程 goctl环境准备[1] 数据库设计 业务开发 新建工程 创建服务目录 创建服务类型（api/rpc/rmq/job/script） 编写api、proto文件 代码生成 生成数据库访问层代码model 配置config，yaml变更 资源依赖填充（ServiceContext） 添加中间件 业务代码填充 错误处理 [!TIP] [1] goctl环境 开发工具 Visual Studio Code Goland(推荐) Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-08 10:20:49 "},"config-introduction.html":{"url":"config-introduction.html","title":"配置介绍","keywords":"","body":"配置介绍 在正式使用go-zero之前，让我们先来了解一下go-zero中不同服务类型的配置定义，看看配置中每个字段分别有什么作用，本节将包含以下小节： api配置 rpc配置 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-08 10:20:49 "},"api-config.html":{"url":"api-config.html","title":"api配置","keywords":"","body":"// api配置 api配置控制着api服务中的各种功能，包含但不限于服务监听地址，端口，环境配置，日志配置等，下面我们从一个简单的配置来看一下api中常用配置分别有什么作用。 配置说明 通过yaml配置我们会发现，有很多参数我们并没有于config对齐，这是因为config定义中，有很多都是带optional或者default 标签的，对于optional可选项，你可以根据自己需求判断是否需要设置，对于default标签，如果你觉得默认值就已经够了，可以不用设置， 一般default中的值基本不用修改，可以认为是最佳实践值。 Config type Config struct{ rest.RestConf // rest api配置 Auth struct { // jwt鉴权配置 AccessSecret string // jwt密钥 AccessExpire int64 // 有效期，单位：秒 } Mysql struct { // 数据库配置，除myql外，可能还有mongo等其他数据库 DataSource string // mysql链接地址，满足 $user:$password@tcp($ip:$port)/$db?$queries 格式即可 } CacheRedis cache.CacheConf // redis缓存 UserRpc zrpc.RpcClientConf // rpc client配置 } rest.RestConf api服务基础配置，包含监听地址，监听端口，证书配置，限流，熔断参数，超时参数等控制，对其展开我们可以看到： service.ServiceConf // service配置 Host string `json:\",default=0.0.0.0\"` // http监听ip，默认0.0.0.0 Port int // http监听端口,必填 CertFile string `json:\",optional\"` // https证书文件，可选 KeyFile string `json:\",optional\"` // https私钥文件，可选 Verbose bool `json:\",optional\"` // 是否打印详细http请求日志 MaxConns int `json:\",default=10000\"` // http同时可接受最大请求数（限流数），默认10000 MaxBytes int64 `json:\",default=1048576,range=[0:8388608]\"` // http可接受请求的最大ContentLength，默认1048576，被设置值不能必须在0到8388608之间 // milliseconds Timeout int64 `json:\",default=3000\"` // 超时时长控制，单位：毫秒，默认3000 CpuThreshold int64 `json:\",default=900,range=[0:1000]\"` // cpu降载阈值，默认900，可允许设置范围0到1000 Signature SignatureConf `json:\",optional\"` // 签名配置 service.ServiceConf type ServiceConf struct { Name string // 服务名称 Log logx.LogConf // 日志配置 Mode string `json:\",default=pro,options=dev|test|pre|pro\"` // 服务环境，dev-开发环境，test-测试环境，pre-预发环境，pro-正式环境 MetricsUrl string `json:\",optional\"` // 指标上报接口地址，该地址需要支持post json即可 Prometheus prometheus.Config `json:\",optional\"` // prometheus配置 } logx.LogConf type LogConf struct { ServiceName string `json:\",optional\"` // 服务名称 Mode string `json:\",default=console,options=console|file|volume\"` // 日志模式，console-输出到console，file-输出到当前服务器（容器）文件，，volume-输出docker挂在文件内 Path string `json:\",default=logs\"` // 日志存储路径 Level string `json:\",default=info,options=info|error|severe\"` // 日志级别 Compress bool `json:\",optional\"` // 是否开启gzip压缩 KeepDays int `json:\",optional\"` // 日志保留天数 StackCooldownMillis int `json:\",default=100\"` // 日志write间隔 } prometheus.Config type Config struct { Host string `json:\",optional\"` // prometheus 监听host Port int `json:\",default=9101\"` // prometheus 监听端口 Path string `json:\",default=/metrics\"` // 上报地址 } SignatureConf SignatureConf struct { Strict bool `json:\",default=false\"` // 是否Strict模式，如果是则PrivateKeys必填 Expiry time.Duration `json:\",default=1h\"` // 有效期，默认1小时 PrivateKeys []PrivateKeyConf // 签名密钥相关配置 } PrivateKeyConf PrivateKeyConf struct { Fingerprint string // 指纹配置 KeyFile string // 密钥配置 } cache.CacheConf ClusterConf []NodeConf NodeConf struct { redis.RedisConf Weight int `json:\",default=100\"` // 权重 } redis.RedisConf RedisConf struct { Host string // redis地址 Type string `json:\",default=node,options=node|cluster\"` // redis类型 Pass string `json:\",optional\"` // redis密码 } Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-08 11:57:50 "},"rpc-config.html":{"url":"rpc-config.html","title":"rpc配置","keywords":"","body":"// rpc配置 rpc配置控制着一个rpc服务的各种功能，包含但不限于监听地址，etcd配置，超时，熔断配置等，下面我们以一个常见的rpc服务配置来进行说明。 配置说明 Config struct { zrpc.RpcServerConf CacheRedis cache.CacheConf // redis缓存配置，详情见api配置说明，这里不赘述 Mysql struct { // mysql数据库访问配置，详情见api配置说明，这里不赘述 DataSource string } } zrpc.RpcServerConf RpcServerConf struct { service.ServiceConf // 服务配置，详情见api配置说明，这里不赘述 ListenOn string // rpc监听地址和端口，如：127.0.0.1:8888 Etcd discov.EtcdConf `json:\",optional\"` // etcd相关配置 Auth bool `json:\",optional\"` // 是否开启Auth，如果是则Redis为必填 Redis redis.RedisKeyConf `json:\",optional\"` // Auth验证 StrictControl bool `json:\",optional\"` // 是否Strict模式，如果是则遇到错误是Auth失败，否则可以认为成功 // pending forever is not allowed // never set it to 0, if zero, the underlying will set to 2s automatically Timeout int64 `json:\",default=2000\"` // 超时控制，单位：毫秒 CpuThreshold int64 `json:\",default=900,range=[0:1000]\"` cpu降载阈值，默认900，可允许设置范围0到1000 } discov.EtcdConf type EtcdConf struct { Hosts []string // etcd host数组 Key string // rpc注册key } redis.RedisKeyConf RedisConf struct { Host string // redis 主机 Type string `json:\",default=node,options=node|cluster\"` // redis类型 Pass string `json:\",optional\"` // redis密码 } RedisKeyConf struct { RedisConf Key string `json:\",optional\"` // 验证key } Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-08 11:57:50 "},"business-dev.html":{"url":"business-dev.html","title":"业务开发","keywords":"","body":"业务开发 本章节我们用一个简单的示例去演示一下go-zero中的一些基本功能。本节将包含一下小节： 目录拆分 model生成 api文件编写 业务编码 jwt鉴权 中间件使用 rpc调用 错误处理 服务启动 演示工程下载 在正式进入后续文档叙述前，可以先留意一下这里的源码，后续我们会基于这份源码进行功能的递进式演示， 而不是完全从0开始，如果你从快速入门章节过来，这份源码结构对你来说不是问题。 点击这里下载演示工程基础源码 演示工程说明 场景 程序员小明需要借阅一本《西游记》，在没有线上图书管理系统的时候，他每天都要去图书馆前台咨询图书馆管理员， 小明：你好，请问今天《西游记》的图书还有吗？ 管理员：没有了，明天再来看看吧。 过了一天，小明又来到图书馆，问： 小明：你好，请问今天《西游记》的图书还有吗？ 管理员：没有了，你过两天再来看看吧。 就这样经过多次反复，小明也是徒劳无功，浪费大量时间在来回的路上，于是终于忍受不了落后的图书管理系统， 他决定自己亲手做一个图书查阅系统。 预期实现目标 用户登录 依靠现有学生系统数据进行登录 图书检索 根据图书关键字搜索图书，查询图书剩余数量。 系统分析 服务拆分 user api 提供用户登录协议 rpc 供search服务访问用户数据 search api 提供图书查询协议 [!TIP] 这个微小的图书借阅查询系统虽然小，从实际来讲不太符合业务场景，但是仅上面两个功能，已经满足我们对go-zero api/rpc的场景演示了， 后续为了满足更丰富的go-zero功能演示，会在文档中进行业务插入即相关功能描述。这里仅用一个场景进行引入。 注意：user中的sql语句请自行创建到db中去，更多准备工作见准备工作 添加一些预设的用户数据到数据库，便于后面使用，为了篇幅，演示工程不对插入数据这种操作做详细演示。 参考预设数据 INSERT INTO `user` (number,name,password,gender)values ('666','小明','123456','男'); Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-09 10:02:51 "},"service-design.html":{"url":"service-design.html","title":"目录拆分","keywords":"","body":"目录拆分 目录拆分是指配合go-zero的最佳实践的目录拆分，这和微服务拆分有着关联，在团队内部最佳实践中， 我们按照业务横向拆分，将一个系统拆分成多个子系统，每个子系统应拥有独立的持久化存储，缓存系统。 如一个商城系统需要有用户系统(user)，商品管理系统(product)，订单系统(order)，购物车系统(cart)，结算中心系统(pay)，售后系统(afterSale)等组成。 系统结构分析 在上文提到的商城系统中，每个系统在对外（http）提供服务的同时，也会提供数据给其他子系统进行数据访问的接口（rpc），因此每个子系统可以拆分成一个服务，而且对外提供了两种访问该系统的方式api和rpc，因此， 以上系统按照目录结构来拆分有如下结构: . ├── afterSale │ └── cmd │ ├── api │ └── rpc ├── cart │ └── cmd │ ├── api │ └── rpc ├── order │ └── cmd │ ├── api │ └── rpc ├── pay │ └── cmd │ ├── api │ └── rpc ├── product │ └── cmd │ ├── api │ └── rpc └── user └── cmd ├── api └── rpc rpc调用链建议 在设计系统时，尽量做到服务之间调用链时单向的，而非循环调用，例如：order服务调用了user服务，而user服务反过来也无调用order的服务， 当其中一个服务启动故障，就会相互影响，进入死循环，你order认为是user服务故障导致的，而user认为是order服务导致的，如果有大量服务存在相互调用链， 则需要考虑服务拆分是否合理。 常见服务类型的目录结构 在上述服务中，仅列举了api/rpc服务，除此之外，一个服务下还可能有其他更多服务类型，如rmq（消息处理系统），cron（定时任务系统），script（脚本）等， 因此一个服务下可能包含一下目录结构： user └── cmd ├── api // http访问服务，业务需求实现 ├── cronjob // 定时任务，定时数据更新业务 ├── rmq // 消息处理系统：mq和dq，处理一些高并发和延时消息业务 ├── rpc // rpc服务，给其他子系统提供基础数据访问 └── script // 脚本，处理一些临时运营需求，临时数据修复 完整工程目录结构示例 mall // 工程名称 ├── common // 通用库 │ ├── randx │ └── stringx ├── go.mod ├── go.sum └── service // 服务存放目录 ├── afterSale │ ├── cmd │ │ ├── api │ │ └── rpc │ └── model ├── cart │ ├── cmd │ │ ├── api │ │ └── rpc │ └── model ├── order │ ├── cmd │ │ ├── api │ │ └── rpc │ └── model ├── pay │ ├── cmd │ │ ├── api │ │ └── rpc │ └── model ├── product │ ├── cmd │ │ ├── api │ │ └── rpc │ └── model └── user ├── cmd │ ├── api │ ├── cronjob │ ├── rmq │ ├── rpc │ └── script └── model 猜你想看 api目录结构介绍 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-08 17:53:01 "},"model-gen.html":{"url":"model-gen.html","title":"model生成","keywords":"","body":"model生成 首先，下载好演示工程 后，我们以user的model来进行代码生成演示。 前言 model是服务访问持久化数据层的桥梁，业务的持久化数据常存在于mysql，mongo等数据库中，我们都知道，对于一个数据库的操作莫过于CURD， 而这些工作也会占用一部分时间来进行开发，我曾经在编写一个业务时写了40个model文件，根据不同业务需求的复杂性，平均每个model文件差不多需要 10分钟，对于40个文件来说，400分钟的工作时间，差不多一天的工作量，而goctl工具可以在10秒钟来完成这400分钟的工作。 准备工作 进入演示工程book，找到user/model下的user.sql文件，将其在你自己的数据库中执行建表。 代码生成(带缓存) 方式一(ddl) 进入book/service/user/model目录，执行命令 $ cd book/service/user/model $ goctl model mysql ddl -src user.sql -dir . -c Done. 方式二(datasource) $ goctl model mysql datasource -url=\"$datasource\" -table=\"user\" -c -dir . Done. [!TIP] $datasource为数据库连接地址 方式三(intellij 插件) 在Goland中，右键user.sql，依次进入并点击New->Go Zero->Model Code即可生成，或者打开user.sql文件， 进入编辑区，使用快捷键Command+N（for mac OS）或者 alt+insert（for windows），选择Mode Code即可 [!TIP] intellij插件生成需要安装goctl插件，详情见intellij插件 验证生成的model文件 查看tree $ tree . ├── user.sql ├── usermodel.go └── vars.go 猜你想看 model命令及其原理 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-08 17:53:01 "},"api-coding.html":{"url":"api-coding.html","title":"api文件编写","keywords":"","body":"api文件编写 编写user.api文件 $ vim service/user/cmd/api/user.api type ( LoginReq { Username string `json:\"username\"` Password string `json:\"password\"` } LoginReply { Id int64 `json:\"id\"` Name string `json:\"name\"` Gender string `json:\"gender\"` AccessToken string `json:\"accessToken\"` AccessExpore int64 `json:\"accessExpore\"` RefreshAfter int64 `json:\"refreshAfter\"` } ) service user-api { @handler login post /user/login (LoginReq) returns (LoginReply) } 生成api服务 方式一 $ cd book/service/user/cmd/api $ goctl api go -api user.api -dir . Done. 方式二 在user.api文件右键，依次点击进入New->Go Zero->Api Code，进入目标目录选择，即api源码的目标存放目录，默认为user.api所在目录，选择好目录后点击OK即可。 方式三 打开user.api，进入编辑区,使用快捷键Command+N（for mac OS）或者 alt+insert（for windows），选择Api Code，同样进入目录选择弹窗，选择好目录后点击OK即可。 猜你想看 api语法 goctl api命令 api目录结构介绍 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-08 17:53:01 "},"business-coding.html":{"url":"business-coding.html","title":"业务编码","keywords":"","body":"业务编码 前面一节，我们已经根据初步需求编写了user.api来描述user服务对外提供哪些服务访问，在本节我们接着前面的步伐， 通过业务编码来讲述go-zero怎么在实际业务中使用。 添加Mysql配置 $ vim service/user/cmd/api/internal/config/config.go package config import \"github.com/tal-tech/go-zero/rest\" type Config struct { rest.RestConf Mysql struct{ DataSource string } CacheRedis cache.CacheConf } 完善yaml配置 $ vim service/user/cmd/api/etc/user-api.yaml Name: user-api Host: 0.0.0.0 Port: 8888 Mysql: DataSource: $user:$password@tcp($url)/$db?charset=utf8mb4&parseTime=true&loc=Asia%2FShanghai CacheRedis: - Host: $host Pass: $pass Type: node [!TIP] $user: mysql数据库user $password: mysql数据库密码 $url: mysql数据库连接地址 $db: mysql数据库db名称，即user表所在database $host: redis连接地址 格式：ip:port,如:127.0.0.1:6379 $pass: redis密码 更多配置信息，请参考api配置介绍 完善服务依赖 $ vim service/user/cmd/api/internal/svc/servicecontext.go type ServiceContext struct { Config config.Config UserModel model.UserModel } func NewServiceContext(c config.Config) *ServiceContext { conn:=sqlx.NewMysql(c.Mysql.DataSource) return &ServiceContext{ Config: c, UserModel: model.NewUserModel(conn,c.CacheRedis), } } 填充登录逻辑 $ vim service/user/cmd/api/internal/logic/loginlogic.go func (l *LoginLogic) Login(req types.LoginReq) (*types.LoginReply, error) { if len(strings.TrimSpace(req.Username)) == 0 || len(strings.TrimSpace(req.Password)) == 0 { return nil, errors.New(\"参数错误\") } userInfo, err := l.svcCtx.UserModel.FindOneByNumber(req.Username) switch err { case nil: case model.ErrNotFound: return nil, errors.New(\"用户名不存在\") default: return nil, err } if userInfo.Password != req.Password { return nil, errors.New(\"用户密码不正确\") } // ---start--- now := time.Now().Unix() accessExpire := l.svcCtx.Config.Auth.AccessExpire jwtToken, err := l.getJwtToken(l.svcCtx.Config.Auth.AccessSecret, now, l.svcCtx.Config.Auth.AccessExpire, userInfo.Id) if err != nil { return nil, err } // ---end--- return &types.LoginReply{ Id: userInfo.Id, Name: userInfo.Name, Gender: userInfo.Gender, AccessToken: jwtToken, AccessExpire: now + accessExpire, RefreshAfter: now + accessExpire/2, }, nil } [!TIP] 上述代码中 [start]-[end]的代码实现见jwt鉴权章节 猜你想看 api语法 goctl api命令 api目录结构介绍 jwt鉴权 api配置介绍 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-08 18:54:19 "},"jwt.html":{"url":"jwt.html","title":"jwt鉴权","keywords":"","body":"jwt鉴权 概述 JSON Web令牌（JWT）是一个开放标准（RFC 7519），它定义了一种紧凑而独立的方法，用于在各方之间安全地将信息作为JSON对象传输。由于此信息是经过数字签名的，因此可以被验证和信任。可以使用秘密（使用HMAC算法）或使用RSA或ECDSA的公钥/私钥对对JWT进行签名。 什么时候应该使用JWT 授权：这是使用JWT的最常见方案。一旦用户登录，每个后续请求将包括JWT，从而允许用户访问该令牌允许的路由，服务和资源。单一登录是当今广泛使用JWT的一项功能，因为它的开销很小并且可以在不同的域中轻松使用。 信息交换：JSON Web令牌是在各方之间安全地传输信息的一种好方法。因为可以对JWT进行签名（例如，使用公钥/私钥对），所以您可以确保发件人是他们所说的人。此外，由于签名是使用标头和有效负载计算的，因此您还可以验证内容是否未被篡改。 为什么要使用JSON Web令牌 由于JSON不如XML冗长，因此在编码时JSON的大小也较小，从而使JWT比SAML更为紧凑。这使得JWT是在HTML和HTTP环境中传递的不错的选择。 在安全方面，只能使用HMAC算法由共享机密对SWT进行对称签名。但是，JWT和SAML令牌可以使用X.509证书形式的公用/专用密钥对进行签名。与签署JSON的简单性相比，使用XML Digital Signature签署XML而不引入模糊的安全漏洞是非常困难的。 JSON解析器在大多数编程语言中都很常见，因为它们直接映射到对象。相反，XML没有自然的文档到对象的映射。与SAML断言相比，这使使用JWT更加容易。 关于用法，JWT是在Internet规模上使用的。这突显了在多个平台（尤其是移动平台）上对JSON Web令牌进行客户端处理的简便性。 [!TIP] 以上内容全部来自jwt官网介绍 go-zero中怎么使用jwt jwt鉴权一般在api层使用，我们这次演示工程中分别在user api登录时生成jwt token，在search api查询图书时验证用户jwt token两步来实现。 user api生成jwt token 接着业务编码章节的内容，我们完善上一节遗留的getJwtToken方法，即生成jwt token逻辑 添加配置定义和yaml配置项 $ vim service/user/cmd/api/internal/config/config.go type Config struct { rest.RestConf Mysql struct{ DataSource string } CacheRedis cache.CacheConf Auth struct { AccessSecret string AccessExpire int64 } } $ vim service/user/cmd/api/etc/user-api.yaml Name: user-api Host: 0.0.0.0 Port: 8888 Mysql: DataSource: $user:$password@tcp($url)/$db?charset=utf8mb4&parseTime=true&loc=Asia%2FShanghai CacheRedis: - Host: $host Pass: $pass Type: node Auth: AccessSecret: $AccessSecret AccessExpire: $AccessExpire [!TIP] $AccessSecret：生成jwt token的密钥，最简单的方式可以使用一个uuid值。 $AccessExpire：jwt token有效期，单位：秒 更多配置信息，请参考api配置介绍 $ vim service/user/cmd/api/internal/logic/loginlogic.go func (l *LoginLogic) getJwtToken(secretKey string, iat, seconds, userId int64) (string, error) { claims := make(jwt.MapClaims) claims[\"exp\"] = iat + seconds claims[\"iat\"] = iat claims[\"userId\"] = userId token := jwt.New(jwt.SigningMethodHS256) token.Claims = claims return token.SignedString([]byte(secretKey)) } search api使用jwt token鉴权 编写search.api文件 $ vim service/search/cmd/api/search.api type ( SearchReq { // 图书名称 Name string `form:\"name\"` } SearchReply { Name string `json:\"name\"` Count int `json:\"count\"` } ) @server( jwt: Auth ) service search-api { @handler search get /search/do (SearchReq) returns (SearchReply) } service search-api { @handler ping get /search/ping } [!TIP] jwt: Auth：开启jwt鉴权 如果路由需要jwt鉴权，则需要在service上方声明此语法标志，如上文中的/search/do 不需要jwt鉴权的路由就无需声明，如上文中/search/ping 更多语法请阅读api语法介绍 生成代码 前面已经描述过有三种方式去生成代码，这里就赘述了。 添加yaml配置项 $ vim service/search/cmd/api/etc/search-api.yaml Name: search-api Host: 0.0.0.0 Port: 8889 Auth: AccessSecret: $AccessSecret AccessExpire: $AccessExpire [!TIP] $AccessSecret：这个值必须要和user api中声明的一致。 这里修改一下端口，避免和user api端口8888冲突 验证 jwt token 启动user api服务，登录 $ cd service/user/cmd/api $ go run user.go -f etc/user-api.yaml Starting server at 0.0.0.0:8888... $ curl -i -X POST \\ http://127.0.0.1:8888/user/login \\ -H 'content-type: application/json' \\ -d '{ \"username\":\"666\", \"password\":\"123456\" }' HTTP/1.1 200 OK Content-Type: application/json Date: Mon, 08 Feb 2021 10:37:54 GMT Content-Length: 251 {\"id\":1,\"name\":\"小明\",\"gender\":\"男\",\"accessToken\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2MTI4NjcwNzQsImlhdCI6MTYxMjc4MDY3NCwidXNlcklkIjoxfQ.JKa83g9BlEW84IiCXFGwP2aSd0xF3tMnxrOzVebbt80\",\"accessExpire\":1612867074,\"refreshAfter\":1612823874} 启动search api服务，调用/search/do验证jwt鉴权是否通过 $ go run search.go -f etc/search-api.yaml Starting server at 0.0.0.0:8889... 我们先不传jwt token，看看结果 $ curl -i -X GET \\ 'http://127.0.0.1:8889/search/do?name=%E8%A5%BF%E6%B8%B8%E8%AE%B0' HTTP/1.1 401 Unauthorized Date: Mon, 08 Feb 2021 10:41:57 GMT Content-Length: 0 很明显，jwt鉴权失败了，返回401的statusCode，接下来我们带一下jwt token（即用户登录返回的accessToken） $ curl -i -X GET \\ 'http://127.0.0.1:8889/search/do?name=%E8%A5%BF%E6%B8%B8%E8%AE%B0' \\ -H 'authorization: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2MTI4NjcwNzQsImlhdCI6MTYxMjc4MDY3NCwidXNlcklkIjoxfQ.JKa83g9BlEW84IiCXFGwP2aSd0xF3tMnxrOzVebbt80' HTTP/1.1 200 OK Content-Type: application/json Date: Mon, 08 Feb 2021 10:44:45 GMT Content-Length: 21 {\"name\":\"\",\"count\":0} [!TIP] 服务启动错误，请查看常见错误处理 至此，jwt从生成到使用就演示完成了，jwt token的鉴权是go-zero内部已经封装了，你只需在api文件中定义服务时简单的声明一下即可。 获取jwt token中携带的信息 go-zero从jwt token解析后会将用户生成token时传入的kv原封不动的放在http.Request的Context中，因此我们可以通过Context就可以拿到你想要的值 $ vim /service/search/cmd/api/internal/logic/searchlogic.go 添加一个log来输出从jwt解析出来的userId。 func (l *SearchLogic) Search(req types.SearchReq) (*types.SearchReply, error) { logx.Infof(\"userId: %v\",l.ctx.Value(\"userId\"))// 这里的key和生成jwt token时传入的key一致 return &types.SearchReply{}, nil } 运行结果 {\"@timestamp\":\"2021-02-09T10:29:09.399+08\",\"level\":\"info\",\"content\":\"userId: 1\"} 猜你想看 jwt介绍 api配置介绍 api语法 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-09 10:32:44 "},"middleware.html":{"url":"middleware.html","title":"中间件使用","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:48:53 "},"rpc-call.html":{"url":"rpc-call.html","title":"rpc调用","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:49:07 "},"error-handle.html":{"url":"error-handle.html","title":"错误处理","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:49:21 "},"service-start.html":{"url":"service-start.html","title":"服务启动","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:49:27 "},"ci-cd.html":{"url":"ci-cd.html","title":"CI/CD","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:49:35 "},"service-deployment.html":{"url":"service-deployment.html","title":"服务部署","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:49:55 "},"log-collection.html":{"url":"log-collection.html","title":"日志收集","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:50:01 "},"service-monitor.html":{"url":"service-monitor.html","title":"服务监控","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:50:07 "},"goctl.html":{"url":"goctl.html","title":"Goctl","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:50:13 "},"goctl-commands.html":{"url":"goctl-commands.html","title":"命令大全","keywords":"","body":"goctl命令大全 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-08 16:04:57 "},"goctl-api.html":{"url":"goctl-api.html","title":"api命令及其原理","keywords":"","body":"api命令及其原理 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-08 16:03:58 "},"goctl-rpc.html":{"url":"goctl-rpc.html","title":"rpc命令及其原理","keywords":"","body":"rpc命令及其原理 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-08 16:04:57 "},"goctl-model.html":{"url":"goctl-model.html","title":"model命令及其原理","keywords":"","body":"model命令及其原理 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-08 16:04:57 "},"goctl-plugin.html":{"url":"goctl-plugin.html","title":"plugin命令及其原理","keywords":"","body":"plugin命令及其原理 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-08 16:07:25 "},"goctl-other.html":{"url":"goctl-other.html","title":"其他命令","keywords":"","body":"其他命令 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-08 16:04:57 "},"component-center.html":{"url":"component-center.html","title":"组件中心","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:50:19 "},"tool-center.html":{"url":"tool-center.html","title":"工具中心","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:50:25 "},"intellij.html":{"url":"intellij.html","title":"intellij插件","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:50:31 "},"vscode.html":{"url":"vscode.html","title":"vscode插件","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:50:37 "},"plugin-center.html":{"url":"plugin-center.html","title":"插件中心","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:50:44 "},"learning-resource.html":{"url":"learning-resource.html","title":"学习资源","keywords":"","body":"学习资源 这里将不定期更新go-zero的最新学习资源通道，目前包含通道有： 公众号 Go夜读 Go开源说 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 14:51:29 "},"wechat.html":{"url":"wechat.html","title":"公众号","keywords":"","body":"公众号 微服务实战是go-zero的官方公众号，在这里会发布最新的go-zero最佳实践，同步go夜读、go开源说、GopherChina、腾讯云开发者大会等多渠道关于go-zero的最新技术和资讯。 公众号名称 公众号作者 公众号二维码 微服务实战 kevwan 干货 这里列举一些干货，想要收获更多go-zero最佳实践干货，可以关注公众号获取最新动态。 《一文读懂云原生 go-zero 微服务框架》 《你还在手撕微服务？快试试 go-zero 的微服务自动生成》 《最简单的Go Dockerfile编写姿势，没有之一！》 《通过MapReduce降低服务响应时间》 《微服务过载保护原理与实战 《最简单的 K8S 部署文件编写姿势，没有之一！》 《go-zero 如何应对海量定时/延迟任务？》 《go-zero 如何扛住流量冲击（一）》 《服务自适应降载保护设计》 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 15:06:52 "},"goreading.html":{"url":"goreading.html","title":"Go夜读","keywords":"","body":"Go夜读 2020-08-16 晓黑板 go-zero 微服务框架的架构设计 2020-10-03 go-zero 微服务框架和线上交流 防止缓存击穿之进程内共享调用 基于go-zero实现JWT认证 再见go-micro！企业项目迁移go-zero全攻略（一） Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 15:02:35 "},"gotalk.html":{"url":"gotalk.html","title":"Go开源说","keywords":"","body":"Go开源说 Go 开源说第四期 - Go-Zero Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 15:04:45 "},"dev-log.html":{"url":"dev-log.html","title":"开发日志","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:51:16 "},"goctl-log.html":{"url":"goctl-log.html","title":"goctl开发日志","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:51:22 "},"intellij-log.html":{"url":"intellij-log.html","title":"intellij开发日志","keywords":"","body":"Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-05 09:51:28 "},"contributor.html":{"url":"contributor.html","title":"社区贡献","keywords":"","body":"社区贡献 作者 kevwan 参与人员(排名不分先后) kingxt anqiansong StevenZack miaogaolin bittoy zhoushuguang Code-Fight xiaowei520 codingfanlt sjatsh knight0zh mywaystay zjbztianya liuximu Alex1996a masonchen2014 YjLeo rcyw voidint wenj91 TonoT foyon defp HappyUncle benyingY cuisongliu yangwenmai weibobo dylanNew WangLeonard Janetyu Jancd microyahoo jiangbohhh chrislee87 supermario1990 ivalue2333 changkun HarryWang29 windk Howie59 wuqinqiang Hkesd almas1992 shenbaise9527 mlboy jichangyun linyihai wwek 注：以上贡献人员为go-zero项目，最后更新于2021年2月5日 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 14:33:54 "},"error.html":{"url":"error.html","title":"常见错误处理","keywords":"","body":"常见错误处理 grpc引起错误 错误一: pb/xx.pb.go:220:7: undefined: grpc.ClientConnInterface pb/xx.pb.go:224:11: undefined: grpc.SupportPackageIsVersion6 pb/xx.pb.go:234:5: undefined: grpc.ClientConnInterface pb/xx.pb.go:237:24: undefined: grpc.ClientConnInterface 解决方法：请将protoc-gen-go版本降至v1.3.2及一下 错误二: # go.etcd.io/etcd/clientv3/balancer/picker ../../../go/pkg/mod/go.etcd.io/etcd@v0.0.0-20200402134248-51bdeb39e698/clientv3/balancer/picker/err.go:25:9: cannot use &errPicker literal (type *errPicker) as type Picker in return argument:*errPicker does not implement Picker (wrong type for Pick method) have Pick(context.Context, balancer.PickInfo) (balancer.SubConn, func(balancer.DoneInfo), error) want Pick(balancer.PickInfo) (balancer.PickResult, error) ../../../go/pkg/mod/go.etcd.io/etcd@v0.0.0-20200402134248-51bdeb39e698/clientv3/balancer/picker/roundrobin_balanced.go:33:9: cannot use &rrBalanced literal (type *rrBalanced) as type Picker in return argument: *rrBalanced does not implement Picker (wrong type for Pick method) have Pick(context.Context, balancer.PickInfo) (balancer.SubConn, func(balancer.DoneInfo), error) want Pick(balancer.PickInfo) (balancer.PickResult, error) #github.com/tal-tech/go-zero/zrpc/internal/balancer/p2c ../../../go/pkg/mod/github.com/tal-tech/go-zero@v1.0.12/zrpc/internal/balancer/p2c/p2c.go:41:32: not enough arguments in call to base.NewBalancerBuilder have (string, *p2cPickerBuilder) want (string, base.PickerBuilder, base.Config) ../../../go/pkg/mod/github.com/tal-tech/go-zero@v1.0.12/zrpc/internal/balancer/p2c/p2c.go:58:9: cannot use &p2cPicker literal (type *p2cPicker) as type balancer.Picker in return argument: *p2cPicker does not implement balancer.Picker (wrong type for Pick method) have Pick(context.Context, balancer.PickInfo) (balancer.SubConn, func(balancer.DoneInfo), error) want Pick(balancer.PickInfo) (balancer.PickResult, error) 解决方法： replace google.golang.org/grpc => google.golang.org/grpc v1.29.1 protoc-gen-go安装失败 go get github.com/golang/protobuf/protoc-gen-go: module github.com/golang/protobuf/protoc-gen-go: Get \"https://proxy.golang.org/github.com/golang/protobuf/protoc-gen-go/@v/list\": dial tcp 216.58.200.49:443: i/o timeout 请确认GOPROXY已经设置,GOPROXY设置见 api服务启动失败 error: config file etc/user-api.yaml, error: type mismatch for field xx 请确认user-api.yaml配置文件中配置项是否已经配置，如果有值，检查一下yaml配置文件是否符合yaml格式。 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-08 18:34:12 "},"source.html":{"url":"source.html","title":"相关源码","keywords":"","body":"相关源码 demo源码 Copyright © 2019-2021 go-zero all right reserved，powered by Gitbook最后更新时间： 2021-02-07 12:40:04 "}}